<?xml version="1.0"?>
<!--
 =======================
  A general telephony Doc   

 =======================

 [History]
 2012-02-18 /usr/share/sgml/docbook/sgml-dtd-4.4-1.0-30.1/docbook.dtd is moto machine
             while "/usr/share/sgml/docbook/sgml-dtd-4.5/docbook.dtd" is my home config.
 2012-02-04 move qcril to msm8960.xml, since here doc is clean and indepent ref doc.
 2011-01-10 Initial Creation
-->
<!DOCTYPE article SYSTEM "/usr/share/sgml/docbook/sgml-dtd-4.4-1.0-30.1/docbook.dtd"
[
<!ENTITY cmd_ping "<userinput>ping_mdm</userinput>">
<!ENTITY section_NV  SYSTEM "sect_nv.xml">
<!ENTITY section_EFS  SYSTEM "sect_efs.xml">
<!ENTITY section_SIM  SYSTEM "sect_sim.xml">
<!ENTITY section_VOICE  SYSTEM "sect_voice_call.xml">
<!ENTITY section_DATA  SYSTEM "sect_data_call.xml">
<!ENTITY section_QMI  SYSTEM "sect_qmi.xml">
<!ENTITY section_SMS  SYSTEM "sect_sms.xml">
<!ENTITY section_PANIC  SYSTEM "sect_panic.xml">
<!ENTITY section_glossary SYSTEM "glossary_section.xml">
<!ENTITY section_index SYSTEM "the_index.xml">
]>

<article>
    <title>Android Telephony Reference Manual</title>
    <articleinfo>
        
        <authorgroup>
        <author>
            <firstname>Yang</firstname><surname>Songxiang</surname>
                <address>
                    <email>a22301@motorola.com</email>
                </address>
            
        </author>
        </authorgroup>
        <copyright>
            <year>2012</year>
            <holder>Motorola Inc.</holder>
        </copyright>

        <abstract>
            <para>This document introduced telephony domain topics on Android platform. It aims
            to provide a clean, and product-independent reference manual, but should mainly focus
            on MSM8960.</para>
            <para>Android OS version is 4.0(Icecream) and later.</para>
        </abstract>
        
    </articleinfo>
    <!-- Overview -->
    <sect1>
        <title>Overview</title>
        
        <para>The whole telephony feature convers at least 3 layers:</para>
        
        <itemizedlist>
            <listitem>
                <para>App/Framework/Base RIL, which is high layer, as part of Android's source code.</para>
            </listitem>
            <listitem>
                <para>Vendor RIL, middle layer, can be proprietary.</para>
            </listitem>
            <listitem>
                <para>Baseband(BP), the lower layer, usually be QualComm's.</para>
            </listitem>
        </itemizedlist>
        
        <para>The whole 3 layer composed the telephony feature, on Android system.</para>
        
        <para><filename>framework/base/telephony/</filename> is the upper layer telephony framework, it
        provides all higer app's services for telephony.</para>
        
        <para><filename>hardware/ril/</filename> is Android's native RIL section, it provides base definition
        and messages, that communicate with vendor ril. Refer <xref linkend="ril.overall_layout" /> for
        more details on the native RIL.</para>
        
        <para>The vendor ril and baseband code varies on different products.</para>
        
        <para>QualComm sometimes call the GSM/WCDMA/UMTS as <emphasis>3gpp</emphasis>, while call CDMA as <emphasis>3gpp2</emphasis>.</para>
        
        <para>So, RIL defined an enum like this:</para>
        
        <informalexample>
            <programlisting>typedef enum {
  RADIO_TECH_3GPP = 1, /* 3GPP Technologies - GSM, WCDMA */
  RADIO_TECH_3GPP2 = 2 /* 3GPP2 Technologies - CDMA */
}RIL_RadioTechnologyFamily;</programlisting>
        </informalexample>
        <!-- Getting Source Code -->
        <sect2>
            <title>Getting Source Code</title>
            
            <para>The Andorid system source code is managed by <emphasis>git/repo</emphasis> tool.</para>
            <para><filename>.repo/manifests/default.xml</filename> contained all projects dir layout.</para>
            <para>We would usually needs change the fetch method, to get source code from mirror site:</para>
            <informalexample>
                <programlisting> &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
 &lt;manifest&gt;
   &lt;remote  name=&quot;repo-blurdev&quot;
<userinput>-           fetch=&quot;ssh://gerrit.pcs.mot.com&quot;</userinput>
<userinput>+           fetch=&quot;/proj/repo01/mirror&quot;</userinput>
            review=&quot;http://gerrit.blurdev.com&quot; /&gt;</programlisting>
            </informalexample>
            <para>We can use <userinput>sed</userinput> tool to do this, the below command is try replace 
            <emphasis>fetch=xxx</emphasis> with <emphasis>fetch=yyy</emphasis>:</para>
            <informalexample>
                <programlisting>sed -i 's/fetch=".*"/fetch="\/proj\/repo01\/mirror"/g' default.xml</programlisting>
            </informalexample>
        </sect2>
        <!-- System Build -->
        <sect2>
            <title>System Build</title>
            
            <para>Except the full build command, Android also provided <userinput>mm</userinput> shell command
            to do quick build.</para>
            
            <para>In order to use the <userinput>mm</userinput>, following items are required:</para>
            <itemizedlist>
            <listitem>
                <para><userinput>. build/envsetup.sh</userinput> to enable the <userinput>mm</userinput> shell command.</para>
            </listitem>
            <listitem>
                <para>Export the <userinput>$TARGET_PRODUCT</userinput></para>
            </listitem>
            <listitem>
                <para>Export the <userinput>$TARGET_BUILD_VARIANT</userinput></para>
            </listitem>
            </itemizedlist>
        </sect2>
        <!-- Debugging and Logging -->
        <sect2>
            <title>Debugging and Logging</title>
            
            <para>The auto logging collection is useful for debugging.</para>
            
            <para>For Tegra arch, like Hubble, we can adding log script in <filename>init.xxx.rc</filename> to do this.</para>
            
            <para>As development keep going, this method is obsoleted in later products. Now it will be controlled by
            <userinput>persist.log.aplogd.enable</userinput> peroperty.</para>
            
            <para>If this property is 1, then logcat log is collected under <filename>/sdcard/logger/</filename> dir.</para>
            
            <para>If we don't want to collect these log, set the property to 0. After reboot, no log collected under
            <filename>/sdcard/logger/</filename>.</para>
            
            <table frame="topbot">
                <title>Auto Log Collecting</title>
                <tgroup cols="2">
                <thead>
                    <row><entry>Property</entry><entry>Note</entry></row>
                </thead>
                <tbody>
                    <row><entry>persist.log.aplogd.enable</entry><entry>1-auto log in /sdcard/logger, 0-stop log</entry></row>
                </tbody>
                </tgroup>
            </table>
            
        </sect2>
        <!-- Powerup Reason -->
        <sect2>
            <title>Powerup Reason</title>
            
            <para>Powerup reason is usually set by bootloader layer.</para>
            
            <example>
                <title>Sample Power Reason definition</title>
                <programlisting><userinput>bootable/bootloader/lk/include/dev/pmic.h</userinput>
#define TIME_OF_DAY_ALARM 0x00000008 /* Bit 3  */
#define USB_CABLE         0x00000010 /* Bit 4  */
#define FACTORY_CABLE 0x00000020 /* Bit 5  */
#define AIRPLANE_MODE 0x00000040 /* Bit 6  */
#define PWR_KEY_PRESS         0x00000080 /* Bit 7  */
#define CHARGER 0x00000100 /* Bit 8  */
#define POWER_CUT 0x00000200 /* Bit 9  */
#define REGRESSION_CABLE 0x00000400 /* Bit 10 */
#define SYSTEM_RESTART         0x00000800 /* Bit 11 */
#define MODEL_ASSEMBLY         0x00001000 /* Bit 12 */
#define MODEL_ASSEMBLY_VOL 0x00002000 /* Bit 13 */
#define SW_AP_RESET 0x00004000 /* Bit 14 */
#define WDOG_AP_RESET 0x00008000 /* Bit 15 */
#define CLKMON_CKIH_RESET 0x00010000 /* Bit 16 */
#define AP_KERNEL_PANIC 0x00020000 /* Bit 17 */
#define CPCAP_WDOG 0x00040000 /* Bit 18 */
#define CIDTCMD 0x00080000 /* Bit 19 */
#define HW_RESET 0x00100000 /* Bit 20 */
#define BP_PANIC 0x00200000 /* Bit 21 */</programlisting>
            </example>
            
            <para>The reason is sotred in <filename>/proc/bootinfo</filename>, below is the text data of this file:</para>
            
            <informalexample>
                <programlisting>SERIAL : 0x20029ead8
HW_REV : 0x8200
POWERUPREASON : 0x00000010
MBM_VERSION : 0x00001095
BATTERY_STATUS_AT_BOOT : 0xffff
CID_RECOVER_BOOT : 0xd7221fba</programlisting>
            </informalexample>
            
            <para><filename>motorola/system/core/mot_boot_mode/mot_boot_mode.c</filename> is a sample util which parse
            the power up info.</para>
            
            <para>We can parse the text, and extract out the POWERUPREASON value, below is a sample source code,
            which will store the valu into a text string(<userinput>bootreason</userinput>):</para>
            
            <example>
                <title>Sample Code to Get Power Reason</title>
                <programlisting>void get_power_reason()
{
  int fd, n;
  char data[BOOTINFO_BUF_LEN];
  
  fd = <userinput>open("/proc/bootinfo", O_RDONLY)</userinput>;
  n = read(fd, data, sizeof(data) - 1);
  data[n] = '\0';
  pwrup_rsn = strstr(data, "POWERUPREASON");
  if (pwrup_rsn) {
      x = strstr(pwrup_rsn, ": ");
      if (x) {
          x += 2;
          n = 0;
          while (*x &amp;&amp; !isspace(*x)) {
              bootreason[n++] = *x; 
              x++;
              if (n == (BUF_LEN - 1)) break;
          }   
          bootreason[n] = '\0';
      }   
  }   
  // <userinput>Now, bootreason[] is text string of power reason!</userinput>
}</programlisting>
            </example>
        </sect2>
    </sect1>
    
    <!-- Upper app layer -->
    <sect1>
        <title>High App Layer</title>
        
        <!-- Phone Creation-->
        <sect2>
            <title>Phone Creation</title>
            <para>Android uses <emphasis>Factory</emphasis> pattern to manage the phone object's creation. Below
            is a sample code that <emphasis>PhoneFactory.java</emphasis> create the target phone object:</para>
            
            <example>
                <title>Code Snippet for Phone Creation</title>
                <programlisting>public static void makeDefaultPhone(Context context){
  int networkMode = Settings.Secure.getInt(
                    Settings.Secure.PREFERRED_NETWORK_MODE);
  ril = new RIL(xxx, networkMode); <lineannotation>Creating RIL based on network type</lineannotation>
  switch(networkMode){
    case XXXX: GSMPhone();
    case YYYY: CDMAPhone();
  }
}</programlisting>
            </example>
            
            <para><emphasis>Radio State</emphasis> is used indicating current <emphasis>BP Machine</emphasis> status,
            because phone is definitely power on, of courese.</para>
            
            <para>Thus, the initial radio state should be <emphasis>unavailable</emphasis>, NOT <emphasis>power off</emphasis>,
            because phone didn't know the BP is on or off, or even not exist at all.</para>
            
                <indexterm><primary>RIL_RadioState</primary></indexterm>
            <para>Radio state is defined as <userinput>RIL_RadioState</userinput> enum by RIL, and below is it's value:</para>
            
            <table frame="topbot">
                <title>Radio State Value</title>
                <tgroup cols="2">
                <thead>
                    <row><entry>Radio Value</entry><entry>Note</entry></row>
                </thead>
                <tbody>
                    <row><entry>RADIO_STATE_OFF(0)</entry><entry>Radio explictly powered off (eg CFUN=0)</entry></row>
                    <row><entry>RADIO_STATE_UNAVAILABLE(1)</entry><entry>Unknow state, radio is resetting or others.</entry></row>
                    <row><entry>RADIO_STATE_ON(10)</entry><entry>Radio On.</entry></row>
                </tbody>
                </tgroup>
            </table>
            
            <note><para>The radio state legacy value 2~9 is obsolted from Android 4.0.</para></note>
            
            <para>RIL defined some req/unsol msg for the radio, to help upper layer and lower layer can exchange the radio
            state correctly:</para>
            <table frame="topbot">
                <title>Radio State Related RIL msg</title>
                <tgroup cols="2">
                <thead>
                    <row><entry>Msg</entry><entry>Note</entry></row>
                </thead>
                <tbody>
                    <row><entry>RIL_REQUEST_RADIO_POWER(23)</entry><entry>Toggle radio on and off (for "airplane" mode)</entry></row>
                    <row><entry>RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED(1000)</entry><entry>Indicate Radio State changed.</entry></row>
                </tbody>
                </tgroup>
            </table>
            
            <sect3>
                <title>Phone Number</title>
                
                <para>The <emphasis>Phone Number</emphasis> is usually a number data stored in SIM card, and we call it
                as <userinput>MDN</userinput>(Mobile Directory Number).</para>
                
                <para>China's mobile phone number is in 11-digit currently, separated by 3 section:</para>
                <example>
                    <title>China 11-digit phone number</title>
                    <programlisting><![CDATA[|  Network  | city-ID | User-ID | 
|===============================|
|  1  3  0  | 2 2 5 9 | 3 5 1 5 | 
|===============================|]]></programlisting>
                </example>
                
                <para>The MDN is stored in <emphasis>E.164</emphasis> standard, also stays in HLR and VLR database.</para>
                
                <example>
                    <title>MDN Number Data</title>
                    <programlisting><![CDATA[
|                |    HLR-ID   | User-ID | 
|==========================================|
|   CC  |   MAC  | H0 H1 H2 H3 |   ABCD    | 
|==========================================|]]></programlisting>
                </example>
                
                <para>Country Code for China is <userinput>86</userinput></para>
            </sect3>
        </sect2>
        
        <!-- FTM and Tools -->
        <sect2>
            <title>FTM and Tools</title>
            
            <para>FTM can be considered as <emphasis>Field Test Menu</emphasis>, or <emphasis>Factory Test Mode</emphasis>.
            It's usually doing data R/W with BP.</para>
            
            <para>Related tools are <emphasis>RadioComm</emphasis>, <emphasis>RSD</emphasis>, <emphasis>QPST</emphasis>.</para>
        </sect2>
        
    </sect1>
    
    <!-- RIL Layer -->
    <sect1>
        <title>RIL Layer</title>
        <sect2 id="ril.overall_layout">
            <title>Overall Layout</title>
            <para>cover libril in hardware/ dir.</para>
        </sect2>
        <!-- Entry Point of Vendro RIL -->
        <sect2>
            <title>Entry Point of Vendro RIL</title>
            
            <para>The <command>RIL_Init()</command> is entry point in vendor RIL, it's a handshake to exchange
            each RIL side's function call address, so later we can know how talk to each other.</para>
            <informalexample>
                <programlisting>const RIL_RadioFunctions *RIL_Init(const struct RIL_Env *env, int argc, char **argv);</programlisting>
            </informalexample>
            <itemizedlist>
                    
                <listitem>
                <para><userinput>argc, argv</userinput> is command option, for more flexible configuration, they are optional.</para>
                </listitem>
                
                <listitem>
                <para><userinput>RIL_RadioFunctions</userinput> is a function set, return back to Android RIL, to let it know
                how to send request, how to get current radio state, etc.</para>
                </listitem>
                
                <listitem>
                <para><userinput>RIL_Env</userinput> is a function set, send in Vendor RIL, tell him if there's any response, unsol
                msg, etc, how to send them back to Android.</para>
                </listitem>
                    
            </itemizedlist>
            
            <para>Thus, <userinput>RIL_Env</userinput> only contains <emphasis>back-way</emphasis> methods:</para>
            <informalexample>
                <programlisting>struct RIL_Env {
  void <userinput>(*OnRequestComplete)</userinput>(...);
  void <userinput>(*OnUnsolicitedResponse)</userinput>(...);
  void <userinput>(*RequestTimedCallback)</userinput> (...);
};</programlisting>
            </informalexample>
        </sect2>
        <!-- RIL Version -->
        <sect2>
            <title>RIL Version</title>
            
            <para>The <emphasis>RIL version</emphasis> composed by 2 parts:</para>
            <itemizedlist>
            <listitem>
                <para>Android Base RIL Version,.</para>
            </listitem>
            <listitem>
                <para>Vendor RIL Version.</para>
            </listitem>
            </itemizedlist>
            
            <para>Android Base RIL Version is released together with Android system:</para>
            <example>
                <title>Base RIL Version</title>
                <programlisting>(hardware/ril/include/telephony/ril.h)
  32 #define RIL_VERSION 6     /* Current version */
  33 #define RIL_VERSION_MIN 2 /* Minimum RIL_VERSION supported */</programlisting>
            </example>
        </sect2>
        
    </sect1>
    <!-- QualComm BP -->
    <sect1>
        <title>QualComm BP</title>
        
        <!-- Overview -->
        <sect2>
            <title>Overview</title>
            
            <para>As current Moto's product design, BP code in always in a dir, like <userinput>mdm6600/</userinput>,
            Moto's specific code is put in <userinput>bpqcom/</userinput> dir, and embeded in 
            <userinput>mdm6600/core/</userinput>:</para>
            
            <informalexample>
                <programlisting><![CDATA[
mdm6600/                bpqcom/
  ./core/bpqcom            ^
       |                   |  
       +-------------------+]]></programlisting>
            </informalexample>
            
            <para>BP source code is build via <userinput>SCONS</userinput>, which is a <emphasis>Python Makefile</emphasis>
            build system.</para>
            
            <para><filename>bpqcom/build/paths.sconscript</filename></para>
            
            <example>
                <title>Moto API Exporting</title>
                <programlisting>  1 Import('env')
  2 
  3 # Public APIs these are accecible by anyone
  4 env.PublishPublicApi('MOTOROLA', [
  5    "${INC_ROOT}/core/bpqcom/mot_base/inc",
  6 ])
  7 
  8 env.PublishPublicApi('MOTUTILS', [
  9    "${INC_ROOT}/core/bpqcom/mot_base/inc",
 10    "${INC_ROOT}/core/bpqcom/mot_utils/inc",
 11 ])
 12 
 13 env.PublishPublicApi('MOTNV', [
 14    "${INC_ROOT}/core/bpqcom/mot_base/inc",
 15    "${INC_ROOT}/core/bpqcom/mot_nv/inc",
 16 ])</programlisting>
            </example>
            
            <para>If you want to use any above component API, just add the name ID in target scon file.</para>
        </sect2>
        
        <!-- Timer -->
        <sect2>
            <title>Timer</title>
            
                <indexterm>
                    <primary>rex_sleep()</primary>
                </indexterm>
            <para>rex_sleep(ms), is the sleep() in QualComm system.</para>
            
                <indexterm>
                    <primary>time_get_secs()</primary>
                </indexterm>
            <para>time_get_secs()</para>
        </sect2>
        
        <!-- Telecom Terminology -->
        <sect2>
            <title>Telecom Terminology</title>
            <!-- ESN/MEID/IMEI -->
            <sect3>
                <title>ESN/MEID/IMEI</title>
                    <indexterm><primary>ESN</primary></indexterm>
                    <indexterm><primary>MEID</primary></indexterm>
                    <indexterm><primary>IMEI</primary></indexterm>
                <para>These 3 IDs all identify the mobile phone device.</para>
                
                <itemizedlist>
                    
                    <listitem>
                    <para>Electronic Serial Number(ESN), 4-byte(32-bit) value, oldest identify method.</para>
                    </listitem>
                    
                    <listitem>
                    <para>Mobile Equipment IDentifier(MEID), as ESN length is too short, MEID uses longer 7-byte to
                    identify a mobile device. It can be in both hex and dec format, and prefer <emphasis>CDMA</emphasis>.</para>
                    </listitem>
                    
                    <listitem>
                    <para>International Mobile Equipment Identity(IMEI), prefer <emphasis>GSM/UMTS</emphasis>, it only in dec format,
                    using a 15-digit(NOT 15-bit) dec number.</para>
                    </listitem>
                    
                </itemizedlist>
                
                <para>These ID can be found at phone back-side, or press <userinput>*#06#</userinput> to show them
                in the pop-up menu(3gpp protocol). Below is result on <emphasis>Moto Droid2</emphasis>:</para>
                
                <figure>
                    <title>Pop-up Menu of MEID(CDMA)</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata scale="50" fileref="res/meid.png" />
                        </imageobject>
                    </mediaobject>
                </figure>
                
                <para>In order to keep back compatibility, ESN/MEID is co-exist in the system. And if ESN is starting
                with <userinput>0x80</userinput>, it means the MEID is enabled.</para>
                
                <para>For example, the <emphasis>ZTE CDMA</emphasis> phone's pop-up menu would show the dec/hex ESN number,
                keep MEID be ZERO:</para>
                <informalexample>
                    <programlisting>ESN (Hex)A715FE84  (Dec)16701441412
MEID 00000000000000</programlisting>
                </informalexample>
                
                <para>For thoes GSM/UMTS mode phone, IMEI would prefered, so <userinput>*#06#</userinput> pop-up menu
                would show IMEI instead of MEID, below is result on <emphasis>Moto Milestone</emphasis>:</para>
                <figure>
                    <title>Pop-up Menu of IMEI(GSM)</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata scale="50" fileref="res/imei.png" />
                        </imageobject>
                    </mediaobject>
                </figure>
                
                <para>QualComm stored these IDs in NV items:</para>
                <table frame="topbot">
                    <title>NV Items for ESN/MEID/IMEI</title>
                    <tgroup cols="2">
                <thead>
                    <row><entry>NV ID</entry><entry>Notes</entry></row>
                </thead>
                <tbody>
                    <row><entry>NV_ESN_I(0)</entry><entry>ESN</entry></row>
                    <row><entry>NV_MEID_I(1943)</entry><entry>MEID</entry></row>
                    <row><entry>NV_UE_IMEI_I(550)</entry><entry>IMEI</entry></row>
                    <row><entry>NV_UE_IMEISV_SVN_I(5153)</entry><entry>IMEISV SVN</entry></row>
                </tbody>
                </tgroup>
                </table>
                
                <para>The NV_UE_IMEI_I's structure is:</para>
                
                <example>
                    <title>Struct for NV_UE_IMEI_I</title>
                    <programlisting>/* Type to hold UE IMEI */
typedef struct PACKED_POST{
  /* International Mobile Equipment Identity */
  byte   ue_imei[NV_UE_IMEI_SIZE]; //<userinput>NV_UE_IMEI_SIZE 9</userinput>
} nv_ue_imei_type;
<userinput>// ue_imei[0] indicate length.</userinput></programlisting>
                </example>
                
                <para>Most of NV_UE_IMEI_I is 8-byte, as conversion between MEID and IMEI occupy extra byte.</para>
                <para>So, the <userinput>ue_imei[0]</userinput> usually be <command>0x08</command>, and <userinput>ue_imei[1]~[8]</userinput> 
                are the byte value.</para>
                
                <para>The inner NV IMEI item data is not plain data shown in the UI, it invovle some conversion of nibble
                swap. Below is a sample how to convert plain IMEI data into the NV item byte data:</para>
                
                <example>
                    <title>An Conversion Number to NV bytes</title>
                    <programlisting><![CDATA[     |  1  |  2  |  3  |  4  |  5  |  6  |  7  | 
     |=========================================|
IMEI | 9 9 | 0 0 | 0 1 | 1 7 | 2 4 | 5 1 | 9 3 | 4  (4 is CHKSM)
     |=========================================|
             
1. First nibble + a', next bytes' nibble combine, consider CHKSM 0
     |----------------------------------------------------|
     | 9+'a'  9 | 0  0 | 0  1 | 1  7 | 2  4 | 5  1 | 9  3 |
     |----------------------------------------------------|
2.      9a     90     00     11     72     45     19    3   0

3. By pass first byte, next byte nibble swap:
        9a     09     00     11     27     54     91     03
        
4. Now, get the whole payload of IMEI NV, add leading byte length(0x08):
(NV_UE_IMEI_I ue_imei[0~8] 0x08 0x9a 0x09 0x00 0x11 0x27 0x54 0x91 0x03)]]></programlisting>
                </example>
                
                <para>The MEID inner data structure is just UINT64, i.e, 8-byte array. The leading byte is 0x00,
                left byte is just MEID's value.</para>
                <para>So, the MEID NV data is plain data stored, which is not like IMEI.</para>
                
                <example>
                    <title>MEID's inner NV data</title>
                    <programlisting>MEID: 99 0C F1 17 24 5A 93
Then NV bytes(8-byte) 00 99 0C F1 17 24 5A 93</programlisting>
                </example>
                
                <para>As an architecture view, the IMEI last 1-digit checksum can be implementaed either in AP or BP.</para>
                <para>For example, <emphasis>RadioComm</emphasis> would read out raw NV data, and calculate the checksum
                by itself.</para>
                
                <para>These code processing on MSM8960 can be found at <xref linkend="qcom.msm8960.sn" />.</para>
            </sect3>
            
            <!-- MCC/MNC/PLMN -->
            <sect3>
                <title>MCC/MNC/PLMN</title>
                
                    <indexterm><primary>MCC</primary></indexterm>
                    <indexterm><primary>MNC</primary></indexterm>
                    <indexterm><primary>PLMN</primary></indexterm>
                <para>These 3 IDs indicating a country's network type.</para>
                <itemizedlist>
                    
                    <listitem>
                    <para>Mobile Country Code(MCC), 3-digit number, specify a country.</para>
                    </listitem>
                    
                    <listitem>
                    <para>Mobile Netowrk Code(MNC), 2-digit(European) or 3-digit(North America), specify a network operator.</para>
                    </listitem>
                    
                    <listitem>
                    <para>Public Land Mobile Network(PLMN), is <userinput>MCC+MNC</userinput>, identify an unique network.</para>
                    </listitem>
                    
                </itemizedlist>
                
                <para>3gpp defines the PLMN number composed by 3-byte:</para>
                <informalexample>
                    <programlisting><![CDATA[           |  8  |  7  |  6  |  5  |  4  |  3  |  2  |  1  |
           |===============================================|
   octet 1 |      MCC Digit 2      |      MCC Digit 1      |
           |-----------------------------------------------|
   octet 2 |      MNC Digit 3      |      MCC Digit 3      |
           |-----------------------------------------------|
   octet 3 |      MNC Digit 2      |      MNC Digit 1      |
           |===============================================|]]></programlisting>
                </informalexample>
                
                <para>So QualComm code defined it in struct like this:</para>
                
                <example>
                    <title>QualComm PLMN ID definition</title>
                    <programlisting>typedef struct sys_plmn_id_s{
  byte  identity[3];
} sys_plmn_id_s_type;</programlisting>
                </example>
                
                <para>Below is some PLMNs in the world:</para>
                <table frame="topbot" id="tbl.mcc.mnc.list">
                    <title>Some PLMNs in the World</title>
                    <tgroup cols="2">
                    <colspec colwidth="1*" />
                    <colspec colwidth="2*" />
                <thead>
                    <row><entry>Country/Network</entry><entry>MCC/MNC</entry></row>
                </thead>
                <tbody>
                    <row><entry>China Mobile</entry><entry>460  00</entry></row>
                    <row><entry>China Unicom</entry><entry>460  01</entry></row>
                    <row><entry>China Telecom</entry><entry>460  03</entry></row>
                    <row><entry>USA Verizon</entry><entry>310 012</entry></row>
                    <row><entry>Canada MTS</entry><entry>302 66</entry></row>
                </tbody>
                </tgroup>
                </table>
            </sect3>
            <!-- NITZ -->
            <sect3>
                <title>NITZ</title>
                    <indexterm><primary>NITZ</primary></indexterm>
                <para>Network Identity and Time Zone(NITZ), provides time service.</para>
                <para>Android RIL defined <userinput>RIL_UNSOL_NITZ_TIME_RECEIVED</userinput> msg, which data is
                in string format <userinput>yy/mm/dd,hh:mm:ss(+/-)tz,dt</userinput>.</para>
                <informalexample>
                    <programlisting>D RILJ    : [UNSL]&lt; UNSOL_NITZ_TIME_RECEIVED 12/03/12,08:10:16+32,00</programlisting>
                </informalexample>
                <para>nitz_nw_info_mnc/nitz_nw_info_mcc</para>
                
            </sect3>
        </sect2>
               
        <!-- AT Commands -->
        <sect2>
            <title>AT Commands</title>
            
            <para>For non-single-chip hardware, most of data was exchanged via AT commands. Some of them are
            3gpp standard, and some are moto-specific, or QualComm-specific.</para>
            
            <note><para>3gpp's 27.007 defined these AT commands.</para></note>
            
            <para>Here lists these commands' referenc information.</para>
            <!-- CIEV -->
            <sect3>
                <title>CIEV</title>
                
                <para>The +CIEV indicates a call(voice, or data)'s connection status. Usually, it's a unsolicit
                msg, and Moto code uses <userinput>~+CIEV</userinput> to mark as a unsolicit msg.</para>
                
                    <indexterm>
                        <primary>CIEV</primary>
                    </indexterm>
                <para>There're totally 3 fields in CIEV:</para>
                
                <informalexample>
                    <programlisting>~+CIEV=calltype,status,reason</programlisting>
                </informalexample>
                
                <para>The code is in mot_rsl layer, below is the code snippet:</para>
                <example>
                    <title>Mot-RSL processing +CIEV</title>
                    <programlisting>void mot_rsl_at_send_ciev(mot_rsl_at_clcc_call_id_type calltype,
    mot_rsl_at_ciev_call_status_type status,
    mot_rsl_at_ciev_reason_code_type reason)</programlisting>
                </example>
                
                
                <table frame="topbot">
                    <title>calltype Field</title>
                    <tgroup cols="2">
                    <colspec colwidth="1*" />
                    <colspec colwidth="2*" />
                <thead>
                    <row><entry>Value</entry><entry>Notes</entry></row>
                </thead>
                <tbody>
                    <row><entry>1</entry><entry>MOT_RSL_AT_CLCC_ID_VOICE</entry></row>
                    <row><entry>2</entry><entry>MOT_RSL_AT_CLCC_ID_DATA_1X</entry></row>
                    <row><entry>3</entry><entry>MOT_RSL_AT_CLCC_ID_DATA_DO</entry></row>
                    <row><entry>4</entry><entry>MOT_RSL_AT_CLCC_ID_DATA_GPRS</entry></row>
                    <row><entry>5</entry><entry>MOT_RSL_AT_CLCC_ID_DATA_WCDMA</entry></row>
                </tbody>
                </tgroup>
                </table>
                <para>For calling someone, the <userinput>calltype</userinput> always be 1.</para>
                
                <table frame="topbot">
                    <title>status Filed</title>
                    <tgroup cols="2">
                    <colspec colwidth="1*" />
                    <colspec colwidth="2*" />
                <thead>
                    <row><entry>Value</entry><entry>Notes</entry></row>
                </thead>
                <tbody>
                    <row><entry>0</entry><entry>MOT_RSL_AT_CIEV_CALL_ENDED</entry></row>
                    <row><entry>1</entry><entry>MOT_RSL_AT_CIEV_CALL_DIALING</entry></row>
                    <row><entry>2</entry><entry>MOT_RSL_AT_CIEV_CALL_CONNECTED</entry></row>
                    <row><entry>3</entry><entry>MOT_RSL_AT_CIEV_CALL_BUSY</entry></row>
                    <row><entry>4</entry><entry>MOT_RSL_AT_CIEV_CALL_INCOMING</entry></row>
                    <row><entry>5</entry><entry>MOT_RSL_AT_CIEV_CALL_DORMANT</entry></row>
                </tbody>
                </tgroup>
                </table>
                
                
                <table frame="topbot">
                    <title>reason Field</title>
                    <tgroup cols="2">
                    <colspec colwidth="1*" />
                    <colspec colwidth="2*" />
                <thead>
                    <row><entry>Value</entry><entry>Notes</entry></row>
                </thead>
                <tbody>
                    <row><entry>0</entry><entry>MOT_RSL_AT_CIEV_REASON_NORMAL</entry></row>
                    <row><entry>1</entry><entry>MOT_RSL_AT_CIEV_REASON_DROP</entry></row>
                    <row><entry>2</entry><entry>MOT_RSL_AT_CIEV_REASON_FAIL</entry></row>
                    <row><entry>3</entry><entry>MOT_RSL_AT_CIEV_REASON_NO_CARRIER</entry></row>
                    <row><entry>4</entry><entry>MOT_RSL_AT_CIEV_REASON_BUSY</entry></row>
                    <row><entry>5</entry><entry>MOT_RSL_AT_CIEV_REASON_FAILED_AUTH</entry></row>
                    <row><entry>6</entry><entry>MOT_RSL_AT_CIEV_REASON_OTHER</entry></row>
                </tbody>
                </tgroup>
                </table>
            </sect3>
            
            <sect3>
                <title>CREG</title>
                <para><emphasis>AT+CREG</emphasis> indicates the registration information, the first 2 fields are
                most important.</para>
                    <indexterm>
                        <primary>CREG</primary>
                    </indexterm>
                <para>There're 10-digit value for the +CREG. They had different meaning for GSM and CDMA network.</para>
                <para>For GSM, the last 5-digit value are all 0, while CDMA used all fields:</para>
                
                <informalexample>
                        <programlisting><lineannotation>+CREG for CDMA</lineannotation>
regStatus,RadioTech, baseID,  baseLat,  baseLong,
   SID,      NID,   Roam_Ind,PRL_match,  EVDO_rev

<lineannotation>+CREG for GSM/UMTS(Last 5-digit are all 0):</lineannotation>
regStatus,RadioTech,LAC,CID,Rej_cause,0,0,0,0,0</programlisting>
                </informalexample>
                
                <para>The reference code level can be found at mot_sys:</para>
                <example>
                        <title>Code for +CREG</title>
                        <programlisting>mot_at_cmd_status_type mot_sys_at_exec_creg_cmd()
{
  if (mot_rsl_is_cdma_mode()){
    sprintf((char*)res_buff_ptr->data_ptr,
      "%s=%d,%d,%d,%ld,%ld,%d,%d,%d,%d,%d\n", tok_ptr->name, rsl.reg.creg, 
      rsl.sys_mode.camp_mode, rsl.bs.bs_id, bs_lat.s, bs_long.s, rsl.bs.bs_sid, 
      rsl.bs.bs_nid, roam_ind,rsl.reg.prl_match,rsl.sys_mode.evdo_rev );
  } else if (mot_rsl_is_gsm_mode()){
    sprintf((char*)res_buff_ptr->data_ptr,
      "%s=%d,%d,%04X,%08lX,%d,0,0,0,0,0\n", tok_ptr->name, rsl.reg.creg,
      rsl.sys_mode.camp_mode, rsl.ss_info.sys_id.id.plmn_lac.lac,
      (rsl.ss_info.cell_info.cell_id > 0x7FFFFFFF) ? 0x7FFFFFFF 
            :rsl.ss_info.cell_info.cell_id,
      rsl.ss_info.reg_reject_info.reject_cause);
  }
  
}</programlisting>
                </example>
                <para>1st field is registration result, mot_rsl_reg_status_e_type is the enum definition</para>
                <table frame="topbot">
                    <title>1st Field - Registration Result</title>
                    <tgroup cols="2">
                
                <thead>
                    <row><entry>Value</entry><entry>Note</entry></row>
                </thead>
                <tbody>
                    <row><entry>MOT_RSL_AT_NET_REG_NO_SERVICE(0)</entry><entry>Not registered, not searching</entry></row>
                    <row><entry>MOT_RSL_AT_NET_REG_HOME(1)</entry><entry>Registered on home network</entry></row>
                    <row><entry>MOT_RSL_AT_NET_REG_SEARCHING(2)</entry><entry>Not registered, searching</entry></row>
                    <row><entry>MOT_RSL_AT_NET_REG_DENIED(3)</entry><entry>Registration denied</entry></row>
                </tbody>
                </tgroup>
                </table>
                
                <para>The 2nd field is RAT(Radio Access Technology), it's mot_rsl_sys_mode_type enum. This enum is mapped
                from QualComm's <userinput>sys_mode</userinput>.</para>
                
                <para>Usually, the higer value, the higer network type.</para>
                <table frame="topbot">
                    <title>2nd field in +CREG(RAT)</title>
                    <tgroup cols="2">
                <colspec colwidth="1*" />
                <colspec colwidth="1*" />
                <thead>
                    <row><entry>Value</entry><entry>Note</entry></row>
                </thead>
                <tbody>
                    <row><entry>MOT_RSL_SYS_MODE_NO_SERVICE(0)</entry><entry>MOT_RSL_SYS_MODE_1X(1)</entry></row>
                    <row><entry>MOT_RSL_SYS_MODE_EVDO(2)</entry><entry>MOT_RSL_SYS_MODE_CDMA_ONLY(3)</entry></row>
                    <row><entry>MOT_RSL_SYS_MODE_GPRS(6)</entry><entry>MOT_RSL_SYS_MODE_EDGE(7)</entry></row>
                    <row><entry>MOT_RSL_SYS_MODE_UMTS(8)</entry><entry>MOT_RSL_SYS_MODE_HSUPA(10)</entry></row>
                    <row><entry>MOT_RSL_SYS_MODE_HSDPA_HSUPA(11)</entry><entry>MOT_RSL_SYS_MODE_HSDPAPLUS(12)</entry></row>
                </tbody>
                </tgroup>
                </table>
            </sect3>
            
            
            <sect3>
                <title>COPS</title>
                <para></para>
                    <indexterm>
                        <primary>COPS</primary>
                    </indexterm>
                <para></para>
            </sect3>
            
            <sect3>
                <title>RSSI</title>
                
                <para>Received Signal Strength Indication(RSSI) is unsolicit message, indicating the signal strength. </para>
                
                <para>Moto handles it in mot_sys layer, different network type, would result in different fields meaning:</para>
                
                <example>
                    <title>+RSSI Fields Processing in mot_sys</title>
                    <programlisting>void  mot_sys_send_rssi()
{
  if (mot_rsl_is_cdma_mode()){
    get_rf_power();
    sprintf(curr_rssi_cmd, "~+RSSI=%d,%d,%d,%d,%d,%d,%d\n",
      cdma_bar, cdma_ecio, cdma_rssi, hdr_bar,  
      hdr_sinr,  hdr_ec, hdr_ecio);
  } else if(mot_rsl_is_gsm_mode()){
    get_gsm_rf_power();
    sprintf(curr_rssi_cmd, "~+RSSI=%d,%d,%d,%d,0,0,0\n",
       gsm_bar, gsm_rssi, gsm_ber, SIG_BAR_NO_SRV);
  }
}</programlisting>
                </example>
                
                    <indexterm>
                        <primary>RSSI</primary>
                    </indexterm>
                <para>As 3gpp's definition, it defined RSSI into a range of 32(0~31) for the signal strength.</para>
                <para>Below table is mapping between the 32-RSSI and dBm:</para>
                <table frame="topbot">
                    <title>RSSI V.S. dBm(3gpp protocol)</title>
                    <tgroup cols="2">
                <thead>
                    <row><entry>RSSI Value</entry><entry>dBm Strength</entry></row>
                </thead>
                <tbody>
                    <row><entry>0</entry><entry>-113dBm, or weaker</entry></row>
                    <row><entry>1</entry><entry>-111dBm</entry></row>
                    <row><entry>2</entry><entry>-109dBm</entry></row>
                    <row><entry>...</entry><entry>...</entry></row>
                    <row><entry>30</entry><entry>-53dBm</entry></row>
                    <row><entry>31</entry><entry>-51dBm, or stronger</entry></row>
                    <row><entry>99</entry><entry>unknown strength</entry></row>
                </tbody>
                </tgroup>
                </table>
                
                <para>There's another term, <userinput>ECIO</userinput>, which is for CDMA</para>
            </sect3>
        </sect2>
        
        <!-- Call Manager(CM) -->
        <sect2 id="qc.cm">
            <title>Call Manager(CM)</title>
            
            <para>The CM component is under <filename>modem/mmode/cm/</filename>, below are some code files:</para>
            <table frame="topbot">
                <title>CM Components</title>
            <tgroup cols="2">
                <colspec colwidth="1*" />
                <colspec colwidth="1*" />
                <thead>
                    <row><entry>Filename</entry><entry>Notes</entry></row>
                </thead>
                <tbody>
                    <row><entry>cm.c</entry><entry>CM Main Entry</entry></row>
                    <row><entry>cmcall.c</entry><entry>Can be considered as <emphasis>Base CM Call</emphasis>.</entry></row>
                    <row><entry>cmxcall.c</entry><entry>CMXxxx.c, is CDMA/HDR specific</entry></row>
                    <row><entry>cmwcall.c</entry><entry>CMWxxx.c, is GMS/WCDMA specific</entry></row>
                    <row><entry>cmss.c</entry><entry>Service System code, the RSSI handling is here.</entry></row>
                </tbody>
            </tgroup>
            </table>
            
            <!-- CM APIs -->
            <sect3>
                <title>CM APIs</title>
                <para>cmcall_event/cmcall_event_2, Notify the client list of a specified call event.</para>
            </sect3>
            
            <!-- CM SS Event -->
            <sect3>
                <title>CM SS Event</title>
                
                <para>The <emphasis>SS Event</emphasis> can indicate a voice call (service status) registration, from
                BP view.</para>
                
                <example>
                    <title>SS Event</title>
                    <programlisting>void cm_client_ss_event_ntfy()
{
  CM_MSG_MED("<userinput>ss evt %d ct %d cid id %d</userinput>", ss_event, client_type, ..);
  client_ptr->ss_event_func( ss_event, ss_info_ptr );
}</programlisting>
                </example>
                
                <para><userinput>CM_SS_EVENT_SRV_CHANGED</userinput> event record the changed fields' info. For example,
                below snippet is <emphasis>Vanquish</emphasis> scaned China Unicom network, and it's signal strength, etc.</para>

                <para>As <emphasis>Vanquish</emphasis> inserts CDMA SIM card in this case, the status is limited, and not
                attached here:</para>
                <example>
                    <title>CM_SS_EVENT_SRV_CHANGED when scaned GSM network</title>
                    <programlisting>Event = 0 (CM_SS_EVENT_SRV_CHANGED) Sevice Status = 1 (Limited Service)
Service Domain = 4 (Found the right system, not yet registered/attached)
Service Capability = 1 (Circuit Switched capable)
System ID Type = UMTS (PLMN = 0x64F010 => [MCC, MNC] = [460, 0115])
RSSI = -62 (dBm)</programlisting>
                </example>

                <para>After the scan, <emphasis>Vanquish</emphasis> finally fond the CDMA network:</para>

                <example>
                    <title>CM_SS_EVENT_SRV_CHANGED when scaned CDMA network</title>
                    <programlisting>Event = 0 (CM_SS_EVENT_SRV_CHANGED)
Sevice Status = 2 (Service Available)
Service Domain = 3 (Circuit and Packet Switched capable)
Service Capability = 3 (Circuit and Packet Switched capable)
System Mode = 2 (CDMA) RSSI = -102 (dBm) ...</programlisting>
                </example>
                    <indexterm><primary>CM SS Event</primary></indexterm>
                <table frame="topbot">
                    <title>CM SS Event</title>
                <tgroup cols="2">
                
                <thead>
                    <row><entry>Value</entry><entry>Notes</entry></row>
                </thead>
                <tbody>
                    <row><entry>CM_SS_EVENT_SRV_CHANGED(0)</entry><entry>Serving system information changed</entry></row>
                    <row><entry>CM_SS_EVENT_RSSI(1)</entry><entry>RSSI changed</entry></row>
                    <row><entry>CM_SS_EVENT_SRV_NEW(7)</entry><entry>Serving system information changed.</entry></row>
                    <row><entry>CM_SS_EVENT_PS_DATA_AVAIL(9)</entry><entry>Received PS data available request</entry></row>
                </tbody>
                </tgroup>
                </table>
            </sect3>
            <!-- Making Call -->
            <sect3>
                <title>Making Call</title>
                <para>The <emphasis>MO Call</emphasis> always starts from <userinput>cmcall_orig_proc()</userinput> in
                <filename>cmcall.c</filename>, and eventually go though <filename>cmxcall.c</filename>.</para>
                
                <para>The <emphasis>Plus Dial</emphasis>:</para>
                <example>
                    <title>Plus Dial Handling</title>
                    <programlisting>static void cmcall_send_mc_orig()
{
  /* <userinput>If number begins with "+" try to convert into digits</userinput> */
  conver_result  = cm_util_perform_num_conversion (num_conv_req,);
  ... ...
  /* If + disabled, BP would log out <userinput>Plus dial is disabled</userinput> */
}</programlisting>
                </example>
                
                <example>
                    <title>Accept Incomming Call</title>
                    <programlisting></programlisting>
                </example>
                
                <para>The call related events are defined as <userinput>cm_call_event_e_type</userinput> in QualComm:</para>
                
                    <indexterm><primary>CM Call Event</primary></indexterm>
                <table frame="topbot">
                    <title>CM Call Event</title>
                <tgroup cols="2">
                
                <thead>
                    <row><entry>Value</entry><entry>Notes</entry></row>
                </thead>
                <tbody>
                    <row><entry>CM_CALL_EVENT_ORIG(0)</entry><entry>Phone originated a call.</entry></row>
                    <row><entry>CM_CALL_EVENT_ANSWER(1)</entry><entry>Incoming call was answered.</entry></row>
                    <row><entry>CM_CALL_EVENT_END(3)</entry><entry>Originated/incoming call was ended.</entry></row>
                    <row><entry>CM_CALL_EVENT_INCOM(5)</entry><entry>Phone received an incoming call.</entry></row>
                    <row><entry>CM_CALL_EVENT_CONNECT(6)</entry><entry>Originated/incoming call was connected.</entry></row>
                    <row><entry>CM_CALL_EVENT_CALLER_ID(10)</entry><entry>Caller ID info was received from the BS. CDMA only.</entry></row>
                </tbody>
                </tgroup>
                </table>
                
                <para>These events log can be found in <filename>modem/dsatcmif.c</filename>(for MSM8960 case):</para>
                <example>
                    <title>CM CALL EVENT log</title>
                    <programlisting>void cmif_call_event_cb_func()
{
  MSG_MED(<userinput>"ATCOP: cm event cb, event: %d, type: %d, state: %d"</userinput>,
     event, event_ptr->call_type, event_ptr->call_state);
}</programlisting>
                </example>
                
                <note><para>Above example should replaced by <filename>void cm_client_call_event_ntfy</filename> in
                cmclient.c! that's the root plase of code!!!</para></note>
                
                <para>The Call Type <userinput>cm_call_type_e_type</userinput>:</para>
                
                <table frame="topbot">
                    <title>CM Call Type Values</title>
                <tgroup cols="2">
                
                <thead>
                    <row><entry>Value</entry><entry>Notes</entry></row>
                </thead>
                <tbody>
                    <row><entry>CM_CALL_TYPE_VOICE(0)</entry><entry>Voice call type.</entry></row>
                    <row><entry>CM_CALL_TYPE_CS_DATA(1)</entry><entry></entry></row>
                    <row><entry>CM_CALL_TYPE_PS_DATA(2)</entry><entry></entry></row>
                    <row><entry>CM_CALL_TYPE_SMS(3)</entry><entry>SMS call type (SMS SO-6 and SO-14). CDMA only.</entry></row>
                </tbody>
                </tgroup>
                </table>
                
                <para>The MO(Orig) Call failure code is defined as <userinput>cm_call_orig_fail_e_type</userinput> enum.</para>
                
                <example>
                    <title>Orig Fail Code</title>
                    <programlisting>(cmdbg.c)
void cmdbg_print_mc_rpt()
{
  case CM_CALL_ORIG_FAIL_F:
    LOG("==CM== CM&lg;&lg; orig fail code %d",
       mc_rpt_ptr->orig_fail.code);
}</programlisting>
                </example>
                
                <table frame="topbot">
                <title>Orig Failure Code</title>
                <tgroup cols="2">
                
                <thead>
                    <row><entry>Value</entry><entry>Notes</entry></row>
                </thead>
                <tbody>
                    <row><entry>CM_CALL_ORIG_ERR_NO_SRV(1)</entry><entry>No Service</entry></row>
                    <row><entry>CM_CALL_ORIG_ERR_ACC_FAIL(2)</entry><entry>Fails due to system access failure.</entry></row>
                    <row><entry>CM_CALL_ORIG_ERR_ABORT(3)</entry><entry>MC cannot process the orig cmd.</entry></row>
                    <row><entry>CM_CALL_ORIG_ACC_IN_PROG(6)</entry><entry>Fails due to access being in progress.</entry></row>
                    <row><entry>CM_CALL_ORIG_ERR_ALREADY_IN_TC(16)</entry><entry>There is already a traffic channel.</entry></row>
                </tbody>
                </tgroup>
                </table>
                
                <para>Please be note that the <emphasis>Failure Code</emphasis> is not the same as <emphasis>End Status</emphasis>,
                there's map relationship between them.</para>
            </sect3>
            
            <!-- Incomming Call -->
            <sect3 id="qc.cm.incommingcall">
                <title>Incomming Call</title>
                <para>For incomming call, the QualComm's CM flow is like this:</para>
                <example>
                    <title>Incomming Call CM event</title>
                    <programlisting><![CDATA[ CM_CALL_EVENT_INCOM(5) (Got from network)
 ---------------->     
     CM_CALL_EVENT_CALLER_ID (10) (Tell the caller info(CLI))
                ---------->   CM_CALL_EVENT_END (3) (user reject the call)]]></programlisting>
                </example>
                
                <para>QualComm defines a <userinput>cm_num_s_type</userinput> as the phone number structure.</para>
                
                <para>If a phone(13022593515) calling another mobile phone, the MO phone number would store as:</para>
                <informalexample>
                    <programlisting>struct {
  uint8 buf[CM_MAX_NUMBER_CHARS]; <userinput>13022593515</userinput>
  uint8 len;  <userinput>11</userinput>
  ...   ...
}cm_num_s_type;</programlisting>
                </informalexample>
            </sect3>
            
            <!-- Call End / Failed -->
            <sect3>
                <title>Call End/Failed</title>
                
                <para><userinput>cmxcall_end()</userinput> in <filename>cmxcall.c</filename> would take care of the end call
                action.</para>
                
                <para>This function contains useful log for <emphasis>Call Status</emphasis>, <emphasis>Call Type</emphasis>, etc.
                We usually need check these value in QXDM log:</para>
                <example>
                    <title>cmxcall_end() for ending call</title>
                    <programlisting>void cmxcall_end()
{
  LOG(<userinput>"CallEnd state=%d status=%d"</userinput>, call_ptr->call_state, call_ptr->end_status);
  LOG(<userinput>"CallType=%d SrvType=%d"</userinput>, call_ptr->call_type, call_ptr->srv_type);
  ...
  ...
}</programlisting>
                </example>
                
                <para>The <emphasis>Call State</emphasis> indicate current Call's state(such as MO/MT/etc). QualComm
                defined it as an enum(<userinput>cm_call_state_e</userinput>).</para>
                <table frame="topbot">
                <title>Call State in BP</title>
                <tgroup cols="2">
                
                <thead>
                    <row><entry>Value</entry><entry>Notes</entry></row>
                </thead>
                <tbody>
                    <row><entry>CM_CALL_STATE_IDLE(0)</entry><entry>Call is in idle state, i.e. no call </entry></row>
                    <row><entry>CM_CALL_STATE_ORIG(1)</entry><entry>Call is in origination state</entry></row>
                    <row><entry>CM_CALL_STATE_INCOM(2)</entry><entry>Call is in alerting state</entry></row>
                    <row><entry>CM_CALL_STATE_CONV(3)</entry><entry>Call is in conversation state</entry></row>
                </tbody>
                </tgroup>
                </table>
            
                <table frame="topbot">
                <title>Call End Status in BP</title>
                <tgroup cols="2">
                
                <thead>
                    <row><entry>Value</entry><entry>Notes</entry></row>
                </thead>
                <tbody>
                    <row><entry>CM_CALL_END_OFFLINE(0)</entry><entry>The phone is offline</entry></row>
                    <row><entry>CM_CALL_END_NO_SRV(21)</entry><entry>No Service, This is for backward compatibility,NO_CDMA_SRV and NO_GW_SRV are mapped to this.</entry></row>
                    <row><entry>CM_CALL_END_INTERCEPT(23)</entry><entry>Received an intercept from the BS -- originating only. CDMA only.</entry></row>
                    <row><entry>CM_CALL_END_CLIENT_END(29)</entry><entry>The client ended the call.</entry></row>
                </tbody>
                </tgroup>
                </table>
            </sect3>
            <!-- FDN -->
            <sect3>
                <title>FDN</title>
                <para>The <emphasis>FDN</emphasis> will restrict your calling.</para>
                <para>It usually needs input your SIM card PIN2 code, before enable FDN.</para>
                    <indexterm>
                        <primary>FDN</primary>
                    </indexterm>
                <para>QualComm code has a <userinput>FEATURE_PACKET_CALL_FDN_CHECK</userinput> flag for support FDN, from
                modem layer.</para>
                <para>So, for <emphasis>MSM8960</emphasis> product, Moto didn't enable it at earlier stage. Later,
                it can add into <filename>build/ms/custaaaaakazq.h</filename> file, to let FDN work.</para>
            </sect3>
            <!-- Speed Dial -->
            <sect3>
                <title>Speed Dial</title>
                
                <para>The <emphasis>Speed Dial</emphasis> would let you assign a phone number to 1-digit number.</para>
                <para>Next time, long-time press that number, phone would dialing the specified long phone number, which
                not require press the whole phone number.</para>
                
                <para>The speed dial is usually applied on Verizon mobile phones.</para>
            </sect3>
            <!-- Call Forward -->
            <sect3>
                <title>Call Forward</title>
                <para>Call Forward topic here</para>
            </sect3>
        
        </sect2>
       
        
        <sect2 id="qcom.msm8960.sn">
            <title>MSM8960 for ESN/MEID/IMEI</title>
            
            <para><filename>modem/datamodem/interface/qmidata/src/ds_qmi_dms.c</filename> handle device's serial number. </para>
            <para>The function usually be <userinput>qmi_dmsi_get_device_serial_numbers()</userinput>, it touched all these 3
            NV items, and it handle a <userinput>NV_UE_IMEISV_SVN_I</userinput> as well.</para>
            
            <para>After get all above data, the <userinput>qmi_dmsi_get_device_serial_numbers()</userinput> return the combined
            response to caller. Below is it's logic flow:</para>
            
            <example>
                <title>Device's ESN/MEID/IMEI handle logic</title>
                <programlisting>static dsm_item_type * qmi_dmsi_get_device_serial_numbers()
{
  dcc_get_nv_item( NV_UE_IMEI_I, dcc_nv_item_ptr ); <lineannotation>get IMEI NV</lineannotation>
  for(i = 1; i &lt;= dcc_nv_item_ptr->ue_imei[0]; i++){
    1. code decode to 14-digit IMEI.
    2. check sum a digit, as the 15-th digit
    3. copy the 15-digit to a value. <lineannotation>RIL use GET_IMEI to get this value.</lineannotation>
  }
  dcc_get_nv_item (NV_ESN_I, dcc_nv_item_ptr); <lineannotation>get ESN NV</lineannotation>
  dcc_get_nv_item (NV_MEID_I, dcc_nv_item_ptr); <lineannotation>get MEID NV</lineannotation>
  dcc_get_nv_item ( NV_UE_IMEISV_SVN_I , dcc_nv_item_ptr); 
  
  return response; <lineannotation>data contain all above data.</lineannotation>
}</programlisting>
            </example>
            
            <para><emphasis>Vanquish</emphasis> handles the MEID/IMEI specially, as required by VZW, it directly
            take 7-byte MEID + 1-digit CHKSM as IMEI, which also be 15-digit. But this required the MEID should not
            have hex nibble!</para>
        </sect2>
        
    </sect1>
    
    <!-- SIM -->
    &section_SIM;
    
    <!-- VOICE -->
    &section_VOICE;
    <!-- DATA Call -->
    &section_DATA;
    <!-- SMS -->
    &section_SMS;
    
    <!-- EFS -->
    &section_EFS;
    
    <!-- NV Item -->
    &section_NV;
    
    <!-- QMI -->
    &section_QMI;
    
    <!-- PANIC -->
    &section_PANIC;
    
    <!-- ============= Glossary =================  -->
    &section_glossary;

    <!-- index -->
    &section_index;
    
</article>
