<?xml version="1.0"?>
<!--
 =======================
  A general telephony Doc   

 =======================

 [History]
 2012-02-18 /usr/share/sgml/docbook/sgml-dtd-4.4-1.0-30.1/docbook.dtd is moto machine
             while "/usr/share/sgml/docbook/sgml-dtd-4.5/docbook.dtd" is my home config.
 2012-02-04 move qcril to msm8960.xml, since here doc is clean and indepent ref doc.
 2011-01-10 Initial Creation
-->
<!DOCTYPE article SYSTEM "/usr/share/sgml/docbook/sgml-dtd-4.4-1.0-30.1/docbook.dtd"
[
<!ENTITY cmd_ping "<userinput>ping_mdm</userinput>">
<!ENTITY section_glossary SYSTEM "glossary_section.xml">
<!ENTITY section_index SYSTEM "the_index.xml">
]>

<article>
    <title>Android Telephony Reference Manual</title>
    <articleinfo>
        
        <authorgroup>
        <author>
            <firstname>Yang</firstname><surname>Songxiang</surname>
                <address>
                    <email>a22301@motorola.com</email>
                </address>
            
        </author>
        </authorgroup>
        <copyright>
            <year>2012</year>
            <holder>Motorola Inc.</holder>
        </copyright>

        <abstract>
            <para>This document introduced telephony domain topics on Android platform. It aims
            to provide a clean, and product-independent reference manual, but should mainly focus
            on MSM8960.</para>
            <para>Android OS version is 4.0(Icecream) and later.</para>
        </abstract>
        
    </articleinfo>
    
    <sect1>
        <title>Overview</title>
        
        <para>The whole telephony feature convers at least 3 layers:</para>
        
        <itemizedlist>
            <listitem>
                <para>App/Framework/Base RIL, which is high layer, as part of Android's source code.</para>
            </listitem>
            <listitem>
                <para>Vendor RIL, which is middle layer, can be proprietary.</para>
            </listitem>
            <listitem>
                <para>Baseband(BP), which is lower layer, usually be QualComm's.</para>
            </listitem>
        </itemizedlist>
        
        <para>The whole 3 layer composed the telephony feature, on Android system.</para>
        
        <para><filename>framework/base/telephony/</filename> is the upper layer telephony framework, it
        provides all higer app's services for telephony.</para>
        
        <para><filename>hardware/ril/</filename> is Android's native RIL section, it provides base definition
        and messages, that communicate with vendor ril. Refer <xref linkend="ril.overall_layout" /> for
        more details on the native RIL.</para>
        
        <para>The vendor ril and baseband code is totally customerizable, and varies on different products.</para>
        
        <para>arch/arm/include/asm/bootinfo.h:34:#define PU_REASON_USB_CABLE    0x00000010 /* Bit 4  */</para>
    </sect1>
    
    <!-- Upper app layer -->
    <sect1>
        <title>High App Layer</title>
        
        <!-- Phone Creation-->
        <sect2>
            <title>Phone Creation</title>
            <para>Android uses <emphasis>Factory</emphasis> pattern to manage the phone object's creation. Below
            is a sample code that <emphasis>PhoneFactory.java</emphasis> create the target phone object:</para>
            
            <example>
                <title>Code Snippet for Phone Creation</title>
                <programlisting>public static void makeDefaultPhone(Context context){
  int networkMode = Settings.Secure.getInt(
                    Settings.Secure.PREFERRED_NETWORK_MODE);
  ril = new RIL(xxx, networkMode); <lineannotation>Creating RIL based on network type</lineannotation>
  switch(networkMode){
    case XXXX: GSMPhone();
    case YYYY: CDMAPhone();
  }
}</programlisting>
            </example>
            
            <para><emphasis>Radio State</emphasis> is used indicating current <emphasis>BP Machine</emphasis> status,
            because phone is definitely power on, of courese.</para>
            
            <para>Thus, the initial radio state should be <emphasis>unavailable</emphasis>, NOT <emphasis>power off</emphasis>,
            because phone didn't know the BP is on or off, or even not exist at all.</para>
            
                <indexterm><primary>RIL_RadioState</primary></indexterm>
            <para>Radio state is defined as <userinput>RIL_RadioState</userinput> enum by RIL, and below is it's value:</para>
            
            <table frame="topbot">
                <title>Radio State Value</title>
                <tgroup cols="2">
                <thead>
                    <row><entry>Radio Value</entry><entry>Note</entry></row>
                </thead>
                <tbody>
                    <row><entry>RADIO_STATE_OFF(0)</entry><entry>Radio explictly powered off (eg CFUN=0)</entry></row>
                    <row><entry>RADIO_STATE_UNAVAILABLE(1)</entry><entry>Unknow state, radio is resetting or others.</entry></row>
                    <row><entry>RADIO_STATE_ON(10)</entry><entry>Radio On.</entry></row>
                </tbody>
                </tgroup>
            </table>
            
            <note><para>The radio state legacy value 2~9 is obsolted from Android 4.0.</para></note>
            
            <para>RIL defined some req/unsol msg for the radio, to help upper layer and lower layer can exchange the radio
            state correctly:</para>
            <table frame="topbot">
                <title>Radio State Related RIL msg</title>
                <tgroup cols="2">
                <thead>
                    <row><entry>Msg</entry><entry>Note</entry></row>
                </thead>
                <tbody>
                    <row><entry>RIL_REQUEST_RADIO_POWER(23)</entry><entry>Toggle radio on and off (for "airplane" mode)</entry></row>
                    <row><entry>RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED(1000)</entry><entry>Indicate Radio State changed.</entry></row>
                </tbody>
                </tgroup>
            </table>
            
            <sect3>
                <title>Phone Number</title>
                
                <para>The <emphasis>Phone Number</emphasis> is usually a number data stored in SIM card, and we call it
                as <userinput>MDN</userinput>(Mobile Directory Number).</para>
                
                <para>China's mobile phone number is in 11-digit currently, separated by 3 section:</para>
                <example>
                    <title>China 11-digit phone number</title>
                    <programlisting><![CDATA[|  Network  | city-ID | User-ID | 
|===============================|
|  1  3  0  | 2 2 5 9 | 3 5 1 5 | 
|===============================|]]></programlisting>
                </example>
                
                <para>The MDN is stored in <emphasis>E.164</emphasis> standard, also stays in HLR and VLR database.</para>
                
                <example>
                    <title>MDN Number Data</title>
                    <programlisting><![CDATA[
|                |    HLR-ID   | User-ID | 
|==========================================|
|   CC  |   MAC  | H0 H1 H2 H3 |   ABCD    | 
|==========================================|]]></programlisting>
                </example>
                
                <para>Country Code for China is <userinput>86</userinput></para>
            </sect3>
        </sect2>
        <!-- Service State Poll -->
        <sect2>
            <title>Service State Poll</title>
            
            <para>Telephony always keep polling the serivice state(SS), it is the high, user-friendly format,
            for current mobile phone's service state data.</para>
            
            <para>So, the icon(like <userinput>3g, 1X</userinput>)'s display info, can be found via the poll RIL log.</para>
            
            <sect3>
                <title>GSM/WCDMA Service State Poll</title>
                <para>Each time of a poll cycle, these state values(old V.S. new), were output in RIL log:</para>
            
            <example>
                <title>GSM Service State Poll in RIL Log</title>
                <programlisting>D/GSM Poll ServiceState done: oldSS=[..] newSS=[..]
                              oldGprs=.. newGprs=..
                              oldType=.. newType=..
                              ...        ...</programlisting>
            </example>
            
            <para>Above old/new SS value output may varies, in different Android version.</para>
            
            <para>But keep in mind this is high level of a user-view, on service state.</para>
            
            <para>The 1st field of <userinput>SS</userinput>, is a <emphasis>ServiceState</emphasis> class instance,
            it's whole definition can be found in <emphasis>ServiceState::toString()</emphasis>. And it's also a moving
            target, in different version, and different product(Motorola changing it as well).</para>
            
            <para>Below demo some fields value in the SS</para>
            
            <table frame="topbot">
                <title>old/newSS fields' value</title>
                <tgroup cols="3">
                <colspec colwidth="1*" />
                <colspec colwidth="2*" />
                <colspec colwidth="3*" />
                <thead>
                    <row><entry>Field</entry><entry>Type</entry><entry>Note</entry></row>
                </thead>
                <tbody>
                    <row><entry>1</entry><entry>state</entry><entry>0-(In Service), 1-(Out Of Service), 2-(Emergency Call)</entry></row>
                    <row><entry>2</entry><entry>roam</entry><entry>true means Roaming.</entry></row>
                    <row><entry>3</entry><entry>OperatorAlpha Long</entry><entry>Long Alpha(such as <userinput>US AT&amp;T</userinput>)</entry></row>
                    <row><entry>4</entry><entry>OperatorAlpha Short</entry><entry>Short Alpha(such as <userinput>AT&amp;T</userinput>)</entry></row>
                </tbody>
                </tgroup>
            </table>
            </sect3>
            <!-- CDMA Service State Poll -->
            <sect3>
                <title>CDMA Service State Poll</title>
                
                <para>For current Android evolution(4.0), the CDMA/LTE service state poll are both put under <filename>cdma/</filename> dir.</para>
                
                <itemizedlist>
                <listitem>
                    <para><filename>telephony/cdma/CdmaServiceStateTracker.java</filename>, CDMA's service state poll file.</para>
                </listitem>
                <listitem>
                    <para><filename>telephony/cdma/CdmaLteServiceStateTracker.java</filename>. LTE/CDMA service state poll, as
                    the Vanquish is for VZW, CDMA/LTE prefered, of course.</para>
                </listitem>
            
                </itemizedlist>
        
                <para>The poll result is similar as GSM/WCDMA, it would output oldSS and newSS.</para>
                
                <example>
                    <title>CdmaLteServiceStateTracker of Poll</title>
                    <programlisting>protected void pollStateDone() {
  ...
  log("pollStateDone: oldSS=[" + ss + "] newSS=[" + newSS + "]");
  ...
  // The output would be like:
  //<userinput>pollStateDone: oldSS=[1 home domestic...EvDo-rev.A:8] newSS=[0 ...]</userinput>
}</programlisting>
                </example>
            </sect3>
            
        </sect2>
        
        <!-- Voice Call -->
        <sect2>
            <title>Voice Call</title>
            
            <para>The <emphasis>Voice Call</emphasis> is composed by below items:</para>
            <itemizedlist>
            <listitem>
                <para>Subscribe with either SIM card, or NV.</para>
            </listitem>
            <listitem>
                <para>Search matching operator, based on subscription(SIM/NV).</para>
            </listitem>
            </itemizedlist>
            
            <!-- Subscribe with SIM/NV -->
            <sect3>
                <title>Subscribe with SIM/NV</title>
                <para></para>
            </sect3>
            
            <!-- Operator -->
            <sect3>
                <title>Operator</title>
                
                <para>The <emphasis>Operator</emphasis> is network carrier PLMN, or Name, dependend on
                implementation.</para>
                
                <para>Telephony is sending <userinput>RIL_REQUEST_OPERATOR</userinput> to RIL, and RIL would
                response 3-field data:</para>
                
                    <indexterm>
                        <primary>OPERATOR</primary>
                    </indexterm>
                <table frame="topbot">
                <title>OPERATOR data field</title>
                <tgroup cols="2">
                
                <thead>
                    <row><entry>Field</entry><entry>Notes</entry></row>
                </thead>
                <tbody>
                    <row><entry>1</entry><entry>long alpha ONS or EONS</entry></row>
                    <row><entry>2</entry><entry>short alpha ONS or EONS</entry></row>
                    <row><entry>3</entry><entry>PLMN(MCC+MNC)</entry></row>
                </tbody>
                </tgroup>
                </table>
                
                <para>Below is an example of <emphasis>China TeleComm</emphasis> CDMA network, it didn't show up the short alpha:</para>
                <informalexample>
                    <programlisting>RILJ    : [0248]> OPERATOR
RILJ    : [0252]&lt; OPERATOR {46003, , 46003}</programlisting>
                </informalexample>
            </sect3>
            
            <sect3>
                <title>Special Calling</title>
                
                <para>There're some <emphasis>special call number</emphasis> by carriers, provide extra service for user.</para>
                
                <para>For example, Verizon always has below service:</para>
                <para><userinput>*67</userinput> - Caller ID Selective Blocking, let you block your name 
                and number from being sent on calls as you make them by pressing <userinput>*67</userinput> before dialing.</para>
            </sect3>
        </sect2>
        
        <!-- Setup Data Call -->
        <sect2>
            <title>Setup Data Call</title>
            
            <para>The data call setup is for data service for browser, etc.</para>
            <para>RIL uses SETUP_DATA_CALL(27) request for this. AP framework would do
            a lot of check to make sure all conditions are meet, before sending this request to BP.</para>
            <para>These checking logic can found in framework code.</para>
                <indexterm>
                    <primary>SETUP_DATA_CALL</primary>
                </indexterm>
            <para>After all condition meets, the setup request would send to RIL. The whole setup request
            contains many fields, current definition is:</para>
            
            <table frame="topbot">
                <title>SETUP_DATA_CALL request</title>
                <tgroup cols="3">
                <colspec colwidth="1*" />
                <colspec colwidth="2*" />
                <colspec colwidth="3*" />
                <thead>
                    <row><entry>Field</entry><entry>Meaning</entry><entry>Notes</entry></row>
                </thead>
                <tbody>
                    <row><entry>1</entry><entry>Radio technology</entry><entry>0(CDMA), 1(GSM/UMTS), above 2 is <userinput>RIL_RadioTechnology+2</userinput></entry></row>
                    <row><entry>2</entry><entry>RIL_DataProfile</entry><entry>This is optional</entry></row>
                    <row><entry>3</entry><entry>APN</entry><entry>For GSM/UMTS case</entry></row>
                    <row><entry>4</entry><entry>APN username</entry><entry>For GSM/UMTS case</entry></row>
                    <row><entry>5</entry><entry>APN password</entry><entry>For GSM/UMTS case</entry></row>
                    <row><entry>6</entry><entry>PAP/CHAP auth type</entry><entry>0(Never PAP/CHAP), 1(may PAP, Never CHAP), 2(may CHAP, Never PAP),3(may PAP/CHAP, depend on BP code)</entry></row>
                    <row><entry>7</entry><entry>Connection type</entry><entry>IP/IPV6/IPV4V6/PPP</entry></row>
                </tbody>
                </tgroup>
            </table>
            
            <para>Below sample is <emphasis>Vanquish</emphasis>, setup data call with China Telecom CDMA network.</para>
            <para>It request 2 type of radio tech in this case:</para>
            <example>
                <title>China Telecom DataCall Setup</title>
                <programlisting><userinput>first try RADIO_TECH_EVDO_A(8) setup:</userinput>
RILJ    : [0133]> SETUP_DATA_CALL 10 0 null null null 3 IP
<userinput>got IP addrss for RADIO_TECH_EVDO_A(8):</userinput>
RILJ    : [0133]&lt; SETUP_DATA_CALL DataCallState: 
       {version=6 status=0 retry=-1 cid=0 active=2 type=IP' 
       ifname='rmnet0' addresses=[49.90.136.7/28] 
        dnses=[61.177.7.1,218.2.135.1] gateways=[49.90.136.1]}
<userinput>disconnected due to Out of Service:</userinput>
CDMA    : [CDMALTEPhone] getDataConnectionState: Data is Out of Service. ret = DISCONNECTED
CDMA    : [CdmaDCT] Data not allowed due to - psState= 1
<userinput>send try RADIO_TECH_EVDO_0(7) setup:</userinput>
RILJ    : [0133]> SETUP_DATA_CALL 9 0 null null null 3 IP
RILJ    : [0133]&lt; SETUP_DATA_CALL DataCallState: 
       {version=6 status=0 retry=-1 cid=0 active=2 type=IP' 
       ifname='rmnet0' addresses=[49.90.136.7/28] 
       dnses=[61.177.7.1,218.2.135.1] gateways=[49.90.136.1]}</programlisting>
            </example>
            
            <sect3>
                <title>Condition Checking</title>
                <para>The <userinput>isDataAllowed()</userinput> would do all the condition checking. If any of them have
                incorrect status, it'll refuse send SETUP_DATA_CALL to RIL.</para>
                <para>So, this function's log is helpful for data connection bug finding:</para>
                
                <table frame="topbot">
                    <title>Data Allowed Checking reasons</title>
                    <tgroup cols="2">
                    <colspec colwidth="1*" />
                    <colspec colwidth="2*" />
                    <thead>
                        <row><entry>Reason</entry><entry>Note</entry></row>
                    </thead>
                    <tbody>
                    <row><entry>gprs = 1</entry><entry>Voice Call not Attached</entry></row>
                    <row><entry>SIM not loaded</entry><entry>Failed detect the SIM card</entry></row>
                    <row><entry>psState = 1</entry><entry>Data is Disabled by user</entry></row>
                    </tbody>
                    </tgroup>
                </table>
            </sect3>
            
            <sect3>
                <title>Data Registration State</title>
                <para>DATA_REGISTRATION_STATE</para>
            </sect3>
            
            <sect3>
                <title>CDMA 1xEV Network</title>
                
                <para>deafult 460036131837427@mycdma.cn, needs re-program the user name and password.</para>
                <para>In QPST Service Program, <guimenu>PPP Config</guimenu>, <guimenu>Um</guimenu> tab username:</para>
                <table frame="topbot">
                <title>NV Items for China TeleCom Auth</title>
                <tgroup cols="2">
                <thead>
                    <row><entry>NV Item</entry><entry>Notes</entry></row>
                </thead>
                <tbody>
                    <row><entry>NV_HDR_AN_AUTH_NAI_I(579)</entry><entry>ctnet@mycdma.cn</entry></row>
                    <row><entry>NV_HDR_AN_AUTH_PASSWORD_I(580)</entry><entry>vnet.mobi</entry></row>
                </tbody>
                </tgroup>
                </table>
                
                <informalexample>
                    <programlisting>9925 typedef PACKED struct PACKED_POST{
 9926   /* length of NAI */
 9927   byte   nai_len;
 9928   /* the NAI */
 9929   byte   nai[NV_MAX_AN_AUTH_NAI_LENGTH];
 9930 } nv_hdr_an_auth_nai_type;</programlisting>
                </informalexample>
                
                
                
            </sect3>
            
        </sect2>
        <!-- FTM and Tools -->
        <sect2>
            <title>FTM and Tools</title>
            
            <para>FTM can be considered as <emphasis>Field Test Menu</emphasis>, or <emphasis>Factory Test Mode</emphasis>.
            It's usually doing data R/W with BP.</para>
            
            <para>Related tools are <emphasis>RadioComm</emphasis>, <emphasis>RSD</emphasis>, <emphasis>QPST</emphasis>.</para>
        </sect2>
        
    </sect1>
    
    <!-- RIL Layer -->
    <sect1>
        <title>RIL Layer</title>
        <sect2 id="ril.overall_layout">
            <title>Overall Layout</title>
            <para>cover libril in hardware/ dir.</para>
        </sect2>
        <!-- Entry Point of Vendro RIL -->
        <sect2>
            <title>Entry Point of Vendro RIL</title>
            
            <para>The <command>RIL_Init()</command> is entry point in vendor RIL, it's a handshake to exchange
            each RIL side's function call address, so later we can know how talk to each other.</para>
            <informalexample>
                <programlisting>const RIL_RadioFunctions *RIL_Init(const struct RIL_Env *env, int argc, char **argv);</programlisting>
            </informalexample>
            <itemizedlist>
                    
                <listitem>
                <para><userinput>argc, argv</userinput> is command option, for more flexible configuration, they are optional.</para>
                </listitem>
                
                <listitem>
                <para><userinput>RIL_RadioFunctions</userinput> is a function set, return back to Android RIL, to let it know
                how to send request, how to get current radio state, etc.</para>
                </listitem>
                
                <listitem>
                <para><userinput>RIL_Env</userinput> is a function set, send in Vendor RIL, tell him if there's any response, unsol
                msg, etc, how to send them back to Android.</para>
                </listitem>
                    
            </itemizedlist>
            
            <para>Thus, <userinput>RIL_Env</userinput> only contains <emphasis>back-way</emphasis> methods:</para>
            <informalexample>
                <programlisting>struct RIL_Env {
  void <userinput>(*OnRequestComplete)</userinput>(...);
  void <userinput>(*OnUnsolicitedResponse)</userinput>(...);
  void <userinput>(*RequestTimedCallback)</userinput> (...);
};</programlisting>
            </informalexample>
        </sect2>
        <!-- RIL Version -->
        <sect2>
            <title>RIL Version</title>
            
            <para>The <emphasis>RIL version</emphasis> composed by 2 parts:</para>
            <itemizedlist>
            <listitem>
                <para>Android Base RIL Version,.</para>
            </listitem>
            <listitem>
                <para>Vendor RIL Version.</para>
            </listitem>
            </itemizedlist>
            
            <para>Android Base RIL Version is released together with Android system:</para>
            <example>
                <title>Base RIL Version</title>
                <programlisting>(hardware/ril/include/telephony/ril.h)
  32 #define RIL_VERSION 6     /* Current version */
  33 #define RIL_VERSION_MIN 2 /* Minimum RIL_VERSION supported */</programlisting>
            </example>
        </sect2>
        <!-- SIM Card Support -->
        <sect2>
            <title>SIM Card Support</title>
            
            <para>The basic and generic information of a SIM card can be found at <xref linkend="qc.simcard" /></para>
            
            <table frame="topbot" id="tbl.ril.simcard.item">
                <title>SIM Related Msg in RIL</title>
                <tgroup cols="2">
                <colspec colwidth="1*" />
                <colspec colwidth="2*" />
                <thead>
                    <row><entry>Msg Type</entry><entry>Note</entry></row>
                </thead>
                <tbody>
                    <row><entry>RIL_REQUEST_GET_SIM_STATUS(1)</entry><entry>Get SIM status</entry></row>
                    <row><entry>RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED(1019)</entry><entry>SIM status changed unsol msg</entry></row>
                    <row><entry>RIL_UNSOL_SIM_SMS_STORAGE_FULL(1016)</entry><entry>SMS storage on the SIM is full.</entry></row>
                </tbody>
                </tgroup>
            </table>
        </sect2>
        <!-- Voice Call Support -->
        <sect2>
            <title>Voice Call Support</title>
            
            <para></para>
            <table frame="topbot" id="tbl.ril.voicecall.item">
                <title>Voice Call Related Msg in RIL</title>
                <tgroup cols="2">
                <colspec colwidth="1*" />
                <colspec colwidth="2*" />
                <thead>
                    <row><entry>Msg Type</entry><entry>Note</entry></row>
                </thead>
                <tbody>
                    <row><entry>RIL_REQUEST_DIAL(10)</entry><entry>Making a phone call</entry></row>
                    <row><entry>RIL_REQUEST_VOICE_REGISTRATION_STATE(20)</entry><entry>Get voice regiteration state</entry></row>
                </tbody>
                </tgroup>
            </table>
            
            <para>The request dial's data is a structure(<userinput>RIL_Dial</userinput>):</para>
            <example>
                <title>Dial Data Structure</title>
                <programlisting>typedef struct {
    char * address;
    int clir; /* (same as 'n' paremeter in TS 27.007 7.7 "+CLIR"
               * clir == 0 on "use subscription default value"
               * clir == 1 on "CLIR invocation" (restrict CLI presentation)
               * clir == 2 on "CLIR suppression" (allow CLI presentation)
               */
    RIL_UUS_Info *  uusInfo; /* NULL or Pointer to User-User Signaling Information */
} RIL_Dial;</programlisting>
            </example>
            
            <para>A flow of an incomming call is like below:</para>
            <example>
                <title>Incomming Call Logic Flow</title>
                    <programlisting><![CDATA[
 RIL                                     BP
  |   UNSOL_RESPONSE_CALL_STATE_CHANGED   |
  | <------------------------------------ |
  |                                       |
  |      REQUEST_GET_CURRENT_CALLS        |
  | ------------------------------------> |
  | <------------------------------------ |
  |     (contained Caller ID info)        |]]></programlisting>
            </example>
            
            <para>We call the incomming call's info as <emphasis>Caller ID</emphasis>, it contained the incomming call's
            number, and other extra info(such as the city, etc).</para>
            
            <para>These info, sometimes, also called as <emphasis>Calling Line Identity</emphasis>(CLI).</para>
            
        </sect2>
    </sect1>
    <!-- QualComm BP -->
    <sect1>
        <title>QualComm BP</title>
        <!-- Telecom Terminology -->
        <sect2>
            <title>Telecom Terminology</title>
            <!-- ESN/MEID/IMEI -->
            <sect3>
                <title>ESN/MEID/IMEI</title>
                    <indexterm><primary>ESN</primary></indexterm>
                    <indexterm><primary>MEID</primary></indexterm>
                    <indexterm><primary>IMEI</primary></indexterm>
                <para>These 3 IDs all identify the mobile phone device.</para>
                
                <itemizedlist>
                    
                    <listitem>
                    <para>Electronic Serial Number(ESN), 4-byte(32-bit) value, oldest identify method.</para>
                    </listitem>
                    
                    <listitem>
                    <para>Mobile Equipment IDentifier(MEID), as ESN length is too short, MEID uses longer 7-byte to
                    identify a mobile device. It can be in both hex and dec format, and prefer <emphasis>CDMA</emphasis>.</para>
                    </listitem>
                    
                    <listitem>
                    <para>International Mobile Equipment Identity(IMEI), prefer <emphasis>GSM/UMTS</emphasis>, it only in dec format,
                    using a 15-digit(NOT 15-bit) dec number.</para>
                    </listitem>
                    
                </itemizedlist>
                
                <para>These ID can be found at phone back-side, or press <userinput>*#06#</userinput> to show them
                in the pop-up menu(3gpp protocol). Below is result on <emphasis>Moto Droid2</emphasis>:</para>
                
                <figure>
                    <title>Pop-up Menu of MEID(CDMA)</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata scale="50" fileref="res/meid.png" />
                        </imageobject>
                    </mediaobject>
                </figure>
                
                <para>In order to keep back compatibility, ESN/MEID is co-exist in the system. And if ESN is starting
                with <userinput>0x80</userinput>, it means the MEID is enabled.</para>
                
                <para>For example, the <emphasis>ZTE CDMA</emphasis> phone's pop-up menu would show the dec/hex ESN number,
                keep MEID be ZERO:</para>
                <informalexample>
                    <programlisting>ESN (Hex)A715FE84  (Dec)16701441412
MEID 00000000000000</programlisting>
                </informalexample>
                
                <para>For thoes GSM/UMTS mode phone, IMEI would prefered, so <userinput>*#06#</userinput> pop-up menu
                would show IMEI instead of MEID, below is result on <emphasis>Moto Milestone</emphasis>:</para>
                <figure>
                    <title>Pop-up Menu of IMEI(GSM)</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata scale="50" fileref="res/imei.png" />
                        </imageobject>
                    </mediaobject>
                </figure>
                
                <para>QualComm stored these IDs in NV items:</para>
                 <table frame="topbot">
                    <title>NV Items for ESN/MEID/IMEI</title>
                    <tgroup cols="2">
                <thead>
                    <row><entry>NV ID</entry><entry>Notes</entry></row>
                </thead>
                <tbody>
                    <row><entry>NV_ESN_I(0)</entry><entry>ESN</entry></row>
                    <row><entry>NV_MEID_I(1943)</entry><entry>MEID</entry></row>
                    <row><entry>NV_UE_IMEI_I(550)</entry><entry>IMEI</entry></row>
                    <row><entry>NV_UE_IMEISV_SVN_I(5153)</entry><entry>IMEISV SVN</entry></row>
                </tbody>
                </tgroup>
                </table>
                
                <para>The NV_UE_IMEI_I's structure is:</para>
                
                <example>
                    <title>Struct for NV_UE_IMEI_I</title>
                    <programlisting>/* Type to hold UE IMEI */
typedef struct PACKED_POST{
  /* International Mobile Equipment Identity */
  byte   ue_imei[NV_UE_IMEI_SIZE]; //<userinput>NV_UE_IMEI_SIZE 9</userinput>
} nv_ue_imei_type;
<userinput>// ue_imei[0] indicate length.</userinput></programlisting>
                </example>
                
                <para>Most of NV_UE_IMEI_I is 8-byte, as conversion between MEID and IMEI occupy extra byte.</para>
                <para>So, the <userinput>ue_imei[0]</userinput> usually be <command>0x08</command>, and <userinput>ue_imei[1]~[8]</userinput> 
                are the byte value.</para>
                
                <para>The inner NV IMEI item data is not plain data shown in the UI, it invovle some conversion of nibble
                swap. Below is a sample how to convert plain IMEI data into the NV item byte data:</para>
                
                <example>
                    <title>An Conversion Number to NV bytes</title>
                    <programlisting><![CDATA[     |  1  |  2  |  3  |  4  |  5  |  6  |  7  | 
     |=========================================|
IMEI | 9 9 | 0 0 | 0 1 | 1 7 | 2 4 | 5 1 | 9 3 | 4  (4 is CHKSM)
     |=========================================|
             
1. First nibble + a', next bytes' nibble combine, consider CHKSM 0
     |----------------------------------------------------|
     | 9+'a'  9 | 0  0 | 0  1 | 1  7 | 2  4 | 5  1 | 9  3 |
     |----------------------------------------------------|
2.      9a     90     00     11     72     45     19    3   0

3. By pass first byte, next byte nibble swap:
        9a     09     00     11     27     54     91     03
        
4. Now, get the whole payload of IMEI NV, add leading byte length(0x08):
(NV_UE_IMEI_I ue_imei[0~8] 0x08 0x9a 0x09 0x00 0x11 0x27 0x54 0x91 0x03)]]></programlisting>
                </example>
                
                <para>The MEID inner data structure is just UINT64, i.e, 8-byte array. The leading byte is 0x00,
                left byte is just MEID's value.</para>
                <para>So, the MEID NV data is plain data stored, which is not like IMEI.</para>
                
                <example>
                    <title>MEID's inner NV data</title>
                    <programlisting>MEID: 99 0C F1 17 24 5A 93
Then NV bytes(8-byte) 00 99 0C F1 17 24 5A 93</programlisting>
                </example>
                
                <para>As an architecture view, the IMEI last 1-digit checksum can be implementaed either in AP or BP.</para>
                <para>For example, <emphasis>RadioComm</emphasis> would read out raw NV data, and calculate the checksum
                by itself.</para>
                
                <para>These code processing on MSM8960 can be found at <xref linkend="qcom.msm8960.sn" />.</para>
            </sect3>
            
            <!-- MCC/MNC/PLMN -->
            <sect3>
                <title>MCC/MNC/PLMN</title>
                
                    <indexterm><primary>MCC</primary></indexterm>
                    <indexterm><primary>MNC</primary></indexterm>
                    <indexterm><primary>PLMN</primary></indexterm>
                <para>These 3 IDs indicating a country's network type.</para>
                <itemizedlist>
                    
                    <listitem>
                    <para>Mobile Country Code(MCC), 3-digit number, specify a country.</para>
                    </listitem>
                    
                    <listitem>
                    <para>Mobile Netowrk Code(MNC), 2-digit(European) or 3-digit(North America), specify a network operator.</para>
                    </listitem>
                    
                    <listitem>
                    <para>Public Land Mobile Network(PLMN), is <userinput>MCC+MNC</userinput>, identify an unique network.</para>
                    </listitem>
                    
                </itemizedlist>
                
                <para>3gpp defines the PLMN number composed by 3-byte:</para>
                <informalexample>
                    <programlisting><![CDATA[           |  8  |  7  |  6  |  5  |  4  |  3  |  2  |  1  |
           |===============================================|
   octet 1 |      MCC Digit 2      |      MCC Digit 1      |
           |-----------------------------------------------|
   octet 2 |      MNC Digit 3      |      MCC Digit 3      |
           |-----------------------------------------------|
   octet 3 |      MNC Digit 2      |      MNC Digit 1      |
           |===============================================|]]></programlisting>
                </informalexample>
                
                <para>So QualComm code defined it in struct like this:</para>
                
                <example>
                    <title>QualComm PLMN ID definition</title>
                    <programlisting>typedef struct sys_plmn_id_s{
  byte  identity[3];
} sys_plmn_id_s_type;</programlisting>
                </example>
                
                <para>Below is some PLMNs in the world:</para>
                <table frame="topbot" id="tbl.mcc.mnc.list">
                    <title>Some PLMNs in the World</title>
                    <tgroup cols="2">
                    <colspec colwidth="1*" />
                    <colspec colwidth="2*" />
                <thead>
                    <row><entry>Country/Network</entry><entry>MCC/MNC</entry></row>
                </thead>
                <tbody>
                    <row><entry>China Mobile(CMCC)</entry><entry>460  00</entry></row>
                    <row><entry>China Unicom</entry><entry>460  01</entry></row>
                    <row><entry>China Telecom</entry><entry>460  03</entry></row>
                    <row><entry>USA Verizon</entry><entry>310 012</entry></row>
                    <row><entry>Canada MTS</entry><entry>302 66</entry></row>
                </tbody>
                </tgroup>
                </table>
            </sect3>
            <!-- NITZ -->
            <sect3>
                <title>NITZ</title>
                    <indexterm><primary>NITZ</primary></indexterm>
                <para>Network Identity and Time Zone(NITZ), provides time service.</para>
                <para>Android RIL defined <userinput>RIL_UNSOL_NITZ_TIME_RECEIVED</userinput> msg, which data is
                in string format <userinput>yy/mm/dd,hh:mm:ss(+/-)tz,dt</userinput>.</para>
                <informalexample>
                    <programlisting>D RILJ    : [UNSL]&lt; UNSOL_NITZ_TIME_RECEIVED 12/03/12,08:10:16+32,00</programlisting>
                </informalexample>
                <para>nitz_nw_info_mnc/nitz_nw_info_mcc</para>
                
            </sect3>
        </sect2>
               
        <!-- AT Commands -->
        <sect2>
            <title>AT Commands</title>
            
            <para>For non-single-chip hardware, most of data was exchanged via AT commands. Some of them are
            3gpp standard, and some are moto-specific, or QualComm-specific.</para>
            
            <note><para>3gpp's 27.007 defined these AT commands.</para></note>
            
            <para>Here lists these commands' referenc information.</para>
            <!-- CIEV -->
            <sect3>
                <title>CIEV</title>
                
                <para>The +CIEV indicates a call(voice, or data)'s connection status. Usually, it's a unsolicit
                msg, and Moto code uses <userinput>~+CIEV</userinput> to mark as a unsolicit msg.</para>
                
                    <indexterm>
                        <primary>CIEV</primary>
                    </indexterm>
                <para>There're totally 3 fields in CIEV:</para>
                
                <informalexample>
                    <programlisting>~+CIEV=calltype,status,reason</programlisting>
                </informalexample>
                
                <para>The code is in mot_rsl layer, below is the code snippet:</para>
                <example>
                    <title>Mot-RSL processing +CIEV</title>
                    <programlisting>void mot_rsl_at_send_ciev(mot_rsl_at_clcc_call_id_type calltype,
    mot_rsl_at_ciev_call_status_type status,
    mot_rsl_at_ciev_reason_code_type reason)</programlisting>
                </example>
                
                
                <table frame="topbot">
                    <title>calltype Field</title>
                    <tgroup cols="2">
                    <colspec colwidth="1*" />
                    <colspec colwidth="2*" />
                <thead>
                    <row><entry>Value</entry><entry>Notes</entry></row>
                </thead>
                <tbody>
                    <row><entry>1</entry><entry>MOT_RSL_AT_CLCC_ID_VOICE</entry></row>
                    <row><entry>2</entry><entry>MOT_RSL_AT_CLCC_ID_DATA_1X</entry></row>
                    <row><entry>3</entry><entry>MOT_RSL_AT_CLCC_ID_DATA_DO</entry></row>
                    <row><entry>4</entry><entry>MOT_RSL_AT_CLCC_ID_DATA_GPRS</entry></row>
                    <row><entry>5</entry><entry>MOT_RSL_AT_CLCC_ID_DATA_WCDMA</entry></row>
                </tbody>
                </tgroup>
                </table>
                <para>For calling someone, the <userinput>calltype</userinput> always be 1.</para>
                
                <table frame="topbot">
                    <title>status Filed</title>
                    <tgroup cols="2">
                    <colspec colwidth="1*" />
                    <colspec colwidth="2*" />
                <thead>
                    <row><entry>Value</entry><entry>Notes</entry></row>
                </thead>
                <tbody>
                    <row><entry>0</entry><entry>MOT_RSL_AT_CIEV_CALL_ENDED</entry></row>
                    <row><entry>1</entry><entry>MOT_RSL_AT_CIEV_CALL_DIALING</entry></row>
                    <row><entry>2</entry><entry>MOT_RSL_AT_CIEV_CALL_CONNECTED</entry></row>
                    <row><entry>3</entry><entry>MOT_RSL_AT_CIEV_CALL_BUSY</entry></row>
                    <row><entry>4</entry><entry>MOT_RSL_AT_CIEV_CALL_INCOMING</entry></row>
                    <row><entry>5</entry><entry>MOT_RSL_AT_CIEV_CALL_DORMANT</entry></row>
                </tbody>
                </tgroup>
                </table>
                
                
                <table frame="topbot">
                    <title>reason Field</title>
                    <tgroup cols="2">
                    <colspec colwidth="1*" />
                    <colspec colwidth="2*" />
                <thead>
                    <row><entry>Value</entry><entry>Notes</entry></row>
                </thead>
                <tbody>
                    <row><entry>0</entry><entry>MOT_RSL_AT_CIEV_REASON_NORMAL</entry></row>
                    <row><entry>1</entry><entry>MOT_RSL_AT_CIEV_REASON_DROP</entry></row>
                    <row><entry>2</entry><entry>MOT_RSL_AT_CIEV_REASON_FAIL</entry></row>
                    <row><entry>3</entry><entry>MOT_RSL_AT_CIEV_REASON_NO_CARRIER</entry></row>
                    <row><entry>4</entry><entry>MOT_RSL_AT_CIEV_REASON_BUSY</entry></row>
                    <row><entry>5</entry><entry>MOT_RSL_AT_CIEV_REASON_FAILED_AUTH</entry></row>
                    <row><entry>6</entry><entry>MOT_RSL_AT_CIEV_REASON_OTHER</entry></row>
                </tbody>
                </tgroup>
                </table>
            </sect3>
            
            <sect3>
                <title>CREG</title>
                <para><emphasis>AT+CREG</emphasis> indicates the registration information, the first 2 fields are
                most important.</para>
                    <indexterm>
                        <primary>CREG</primary>
                    </indexterm>
                <para>There're 10-digit value for the +CREG. They had different meaning for GSM and CDMA network.</para>
                <para>For GSM, the last 5-digit value are all 0, while CDMA used all fields:</para>
                
                <informalexample>
                        <programlisting><lineannotation>+CREG for CDMA</lineannotation>
regStatus,RadioTech, baseID,  baseLat,  baseLong,
   SID,      NID,   Roam_Ind,PRL_match,  EVDO_rev

<lineannotation>+CREG for GSM/UMTS(Last 5-digit are all 0):</lineannotation>
regStatus,RadioTech,LAC,CID,Rej_cause,0,0,0,0,0</programlisting>
                </informalexample>
                
                <para>The reference code level can be found at mot_sys:</para>
                <example>
                        <title>Code for +CREG</title>
                        <programlisting>mot_at_cmd_status_type mot_sys_at_exec_creg_cmd()
{
  if (mot_rsl_is_cdma_mode()){
    sprintf((char*)res_buff_ptr->data_ptr,
      "%s=%d,%d,%d,%ld,%ld,%d,%d,%d,%d,%d\n", tok_ptr->name, rsl.reg.creg, 
      rsl.sys_mode.camp_mode, rsl.bs.bs_id, bs_lat.s, bs_long.s, rsl.bs.bs_sid, 
      rsl.bs.bs_nid, roam_ind,rsl.reg.prl_match,rsl.sys_mode.evdo_rev );
  } else if (mot_rsl_is_gsm_mode()){
    sprintf((char*)res_buff_ptr->data_ptr,
      "%s=%d,%d,%04X,%08lX,%d,0,0,0,0,0\n", tok_ptr->name, rsl.reg.creg,
      rsl.sys_mode.camp_mode, rsl.ss_info.sys_id.id.plmn_lac.lac,
      (rsl.ss_info.cell_info.cell_id > 0x7FFFFFFF) ? 0x7FFFFFFF 
            :rsl.ss_info.cell_info.cell_id,
      rsl.ss_info.reg_reject_info.reject_cause);
  }
  
}</programlisting>
                </example>
                <para>1st field is registration result, mot_rsl_reg_status_e_type is the enum definition</para>
                <table frame="topbot">
                    <title>1st Field - Registration Result</title>
                    <tgroup cols="2">
                
                <thead>
                    <row><entry>Value</entry><entry>Note</entry></row>
                </thead>
                <tbody>
                    <row><entry>MOT_RSL_AT_NET_REG_NO_SERVICE(0)</entry><entry>Not registered, not searching</entry></row>
                    <row><entry>MOT_RSL_AT_NET_REG_HOME(1)</entry><entry>Registered on home network</entry></row>
                    <row><entry>MOT_RSL_AT_NET_REG_SEARCHING(2)</entry><entry>Not registered, searching</entry></row>
                    <row><entry>MOT_RSL_AT_NET_REG_DENIED(3)</entry><entry>Registration denied</entry></row>
                </tbody>
                </tgroup>
                </table>
                
                <para>The 2nd field is RAT(Radio Access Technology), it's mot_rsl_sys_mode_type enum. This enum is mapped
                from QualComm's <userinput>sys_mode</userinput>.</para>
                
                <para>Usually, the higer value, the higer network type.</para>
                <table frame="topbot">
                    <title>2nd field in +CREG(RAT)</title>
                    <tgroup cols="2">
                <colspec colwidth="1*" />
                <colspec colwidth="1*" />
                <thead>
                    <row><entry>Value</entry><entry>Note</entry></row>
                </thead>
                <tbody>
                    <row><entry>MOT_RSL_SYS_MODE_NO_SERVICE(0)</entry><entry>MOT_RSL_SYS_MODE_1X(1)</entry></row>
                    <row><entry>MOT_RSL_SYS_MODE_EVDO(2)</entry><entry>MOT_RSL_SYS_MODE_CDMA_ONLY(3)</entry></row>
                    <row><entry>MOT_RSL_SYS_MODE_GPRS(6)</entry><entry>MOT_RSL_SYS_MODE_EDGE(7)</entry></row>
                    <row><entry>MOT_RSL_SYS_MODE_UMTS(8)</entry><entry>MOT_RSL_SYS_MODE_HSUPA(10)</entry></row>
                    <row><entry>MOT_RSL_SYS_MODE_HSDPA_HSUPA(11)</entry><entry>MOT_RSL_SYS_MODE_HSDPAPLUS(12)</entry></row>
                </tbody>
                </tgroup>
                </table>
            </sect3>
            
            
            <sect3>
                <title>COPS</title>
                <para></para>
                    <indexterm>
                        <primary>COPS</primary>
                    </indexterm>
                <para></para>
            </sect3>
            
            <sect3>
                <title>RSSI</title>
                
                <para>Received Signal Strength Indication(RSSI) is unsolicit message, indicating the signal strength. </para>
                
                <para>Moto handles it in mot_sys layer, different network type, would result in different fields meaning:</para>
                
                <example>
                    <title>+RSSI Fields Processing in mot_sys</title>
                    <programlisting>void  mot_sys_send_rssi()
{
  if (mot_rsl_is_cdma_mode()){
    get_rf_power();
    sprintf(curr_rssi_cmd, "~+RSSI=%d,%d,%d,%d,%d,%d,%d\n",
      cdma_bar, cdma_ecio, cdma_rssi, hdr_bar,  
      hdr_sinr,  hdr_ec, hdr_ecio);
  } else if(mot_rsl_is_gsm_mode()){
    get_gsm_rf_power();
    sprintf(curr_rssi_cmd, "~+RSSI=%d,%d,%d,%d,0,0,0\n",
       gsm_bar, gsm_rssi, gsm_ber, SIG_BAR_NO_SRV);
  }
}</programlisting>
                </example>
                
                    <indexterm>
                        <primary>RSSI</primary>
                    </indexterm>
                <para>As 3gpp's definition, it defined RSSI into a range of 32(0~31) for the signal strength.</para>
                <para>Below table is mapping between the 32-RSSI and dBm:</para>
                <table frame="topbot">
                    <title>RSSI V.S. dBm(3gpp protocol)</title>
                    <tgroup cols="2">
                <thead>
                    <row><entry>RSSI Value</entry><entry>dBm Strength</entry></row>
                </thead>
                <tbody>
                    <row><entry>0</entry><entry>-113dBm, or weaker</entry></row>
                    <row><entry>1</entry><entry>-111dBm</entry></row>
                    <row><entry>2</entry><entry>-109dBm</entry></row>
                    <row><entry>...</entry><entry>...</entry></row>
                    <row><entry>30</entry><entry>-53dBm</entry></row>
                    <row><entry>31</entry><entry>-51dBm, or stronger</entry></row>
                    <row><entry>99</entry><entry>unknown strength</entry></row>
                </tbody>
                </tgroup>
                </table>
                
                <para>There's another term, <userinput>ECIO</userinput>, which is for CDMA</para>
            </sect3>
        </sect2>
        
        <!-- SIM Card -->
        <sect2 id="qc.simcard">
            <title>SIM Card</title>
            <para></para>
            
            <sect3>
                <title>IMSI</title>
                    <indexterm><primary>IMSI</primary></indexterm>
                <para>EF_IMSI 0x6F07</para>
            </sect3>
        </sect2>
        
        <sect2>
            <title>Sys Mode</title>
            <para></para>
                    <indexterm>
                        <primary>sys_mode</primary>
                    </indexterm>
                    
            <table frame="topbot">
                <title>sys_mode values</title>
            <tgroup cols="2">
                <colspec colwidth="1*" />
                <colspec colwidth="1*" />
                <thead>
                    <row><entry>value</entry><entry>Notes</entry></row>
                </thead>
                <tbody>
                    <row><entry>SYS_SYS_MODE_NO_SRV 0</entry><entry>SYS_SYS_MODE_AMPS 1</entry></row>
                    <row><entry>SYS_SYS_MODE_CDMA 2</entry><entry>SYS_SYS_MODE_GSM  3</entry></row>
                    <row><entry>SYS_SYS_MODE_HDR 4</entry><entry>SYS_SYS_MODE_WCDMA 5</entry></row>
                    <row><entry>SYS_SYS_MODE_GPS 6</entry><entry>SYS_SYS_MODE_GW 7 (GSM+WCDMA)</entry></row>
                    <row><entry>SYS_SYS_MODE_WLAN 8</entry><entry>SYS_SYS_MODE_LTE 9</entry></row>
                    <row><entry>SYS_SYS_MODE_GWL 10(GSM+WCDMA+LTE)</entry><entry>SYS_SYS_MODE_TDS 11</entry></row>
                </tbody>
            </tgroup>
            </table>
        </sect2>
        
        <!-- Call Manager(CM) -->
        <sect2 id="qc.cm">
            <title>Call Manager(CM)</title>
            
            <para>The CM component is under <filename>modem/mmode/cm/</filename>, below are some code files:</para>
            <table frame="topbot">
                <title>CM Components</title>
            <tgroup cols="2">
                <colspec colwidth="1*" />
                <colspec colwidth="1*" />
                <thead>
                    <row><entry></entry><entry>Notes</entry></row>
                </thead>
                <tbody>
                    <row><entry>cm.c</entry><entry>CM Main Entry</entry></row>
                    <row><entry>cmcall.c</entry><entry>Can be considered as <emphasis>Base CM Call</emphasis>.</entry></row>
                    <row><entry>cmxcall.c</entry><entry><emphasis>Extended Call</emphasis>, based on cmcall.c</entry></row>
                    <row><entry>cmss.c</entry><entry>Service System code, the RSSI handling is here.</entry></row>
                </tbody>
            </tgroup>
            </table>
            <!-- CM SS Event -->
            <sect3>
                <title>CM SS Event</title>
                
                <para>The <emphasis>SS Event</emphasis> can indicate a voice call (service status) registration, from
                BP view.</para>
                
                <example>
                    <title>SS Event</title>
                    <programlisting>void cm_client_ss_event_ntfy()
{
  CM_MSG_MED("<userinput>ss evt %d ct %d cid id %d</userinput>", ss_event, client_type, ..);
  client_ptr->ss_event_func( ss_event, ss_info_ptr );
}</programlisting>
                </example>
                
                <para><userinput>CM_SS_EVENT_SRV_CHANGED</userinput> event record the changed fields' info. For example,
                below snippet is <emphasis>Vanquish</emphasis> scaned China Unicom network, and it's signal strength, etc.</para>

                <para>As <emphasis>Vanquish</emphasis> inserts CDMA SIM card in this case, the status is limited, and not
                attached here:</para>
                <example>
                    <title>CM_SS_EVENT_SRV_CHANGED when scaned GSM network</title>
                    <programlisting>Event = 0 (CM_SS_EVENT_SRV_CHANGED) Sevice Status = 1 (Limited Service)
Service Domain = 4 (Found the right system, not yet registered/attached)
Service Capability = 1 (Circuit Switched capable)
System ID Type = UMTS (PLMN = 0x64F010 => [MCC, MNC] = [460, 0115])
RSSI = -62 (dBm)</programlisting>
                </example>

                <para>After the scan, <emphasis>Vanquish</emphasis> finally fond the CDMA network:</para>

                <example>
                    <title>CM_SS_EVENT_SRV_CHANGED when scaned CDMA network</title>
                    <programlisting>Event = 0 (CM_SS_EVENT_SRV_CHANGED)
Sevice Status = 2 (Service Available)
Service Domain = 3 (Circuit and Packet Switched capable)
Service Capability = 3 (Circuit and Packet Switched capable)
System Mode = 2 (CDMA) RSSI = -102 (dBm) ...</programlisting>
                </example>
                    <indexterm><primary>CM SS Event</primary></indexterm>
                <table frame="topbot">
                    <title>CM SS Event</title>
                <tgroup cols="2">
                
                <thead>
                    <row><entry>Value</entry><entry>Notes</entry></row>
                </thead>
                <tbody>
                    <row><entry>CM_SS_EVENT_SRV_CHANGED(0)</entry><entry>Serving system information changed</entry></row>
                    <row><entry>CM_SS_EVENT_RSSI(1)</entry><entry>RSSI changed</entry></row>
                    <row><entry>CM_SS_EVENT_SRV_NEW(7)</entry><entry>Serving system information changed.</entry></row>
                    <row><entry>CM_SS_EVENT_PS_DATA_AVAIL(9)</entry><entry>Received PS data available request</entry></row>
                </tbody>
                </tgroup>
                </table>
            </sect3>
            <!-- Making Call -->
            <sect3>
                <title>Making Call</title>
                <para>The <emphasis>MO Call</emphasis> always starts from <userinput>cmcall_orig_proc()</userinput> in
                <filename>cmcall.c</filename>, and eventually go though <filename>cmxcall.c</filename>.</para>
                
                <para>The <emphasis>Plus Dial</emphasis>:</para>
                <example>
                    <title>Plus Dial Handling</title>
                    <programlisting>static void cmcall_send_mc_orig()
{
  /* <userinput>If number begins with "+" try to convert into digits</userinput> */
  conver_result  = cm_util_perform_num_conversion (num_conv_req,);
  ... ...
  /* If + disabled, BP would log out <userinput>Plus dial is disabled</userinput> */
}</programlisting>
                </example>
                
                <example>
                    <title>Accept Incomming Call</title>
                    <programlisting></programlisting>
                </example>
                
                <para>The call related events are defined as <userinput>cm_call_event_e_type</userinput> in QualComm:</para>
                
                    <indexterm><primary>CM Call Event</primary></indexterm>
                <table frame="topbot">
                    <title>CM Call Event</title>
                <tgroup cols="2">
                
                <thead>
                    <row><entry>Value</entry><entry>Notes</entry></row>
                </thead>
                <tbody>
                    <row><entry>CM_CALL_EVENT_ORIG(0)</entry><entry>Phone originated a call.</entry></row>
                    <row><entry>CM_CALL_EVENT_ANSWER(1)</entry><entry>Incoming call was answered.</entry></row>
                    <row><entry>CM_CALL_EVENT_END(3)</entry><entry>Originated/incoming call was ended.</entry></row>
                    <row><entry>CM_CALL_EVENT_INCOM(5)</entry><entry>Phone received an incoming call.</entry></row>
                    <row><entry>CM_CALL_EVENT_CONNECT(6)</entry><entry>Originated/incoming call was connected.</entry></row>
                    <row><entry>CM_CALL_EVENT_CALLER_ID(10)</entry><entry>Caller ID info was received from the BS. CDMA only.</entry></row>
                </tbody>
                </tgroup>
                </table>
                <para>These events log can be found in <filename>modem/dsatcmif.c</filename>(for MSM8960 case):</para>
                <example>
                    <title>CM CALL EVENT log</title>
                    <programlisting>void cmif_call_event_cb_func()
{
  MSG_MED(<userinput>"ATCOP: cm event cb, event: %d, type: %d, state: %d"</userinput>,
     event, event_ptr->call_type, event_ptr->call_state);
}</programlisting>
                </example>
            </sect3>
            <!-- Incomming Call -->
            <sect3 id="qc.cm.incommingcall">
                <title>Incomming Call</title>
                <para>For incomming call, the QualComm's CM flow is like this:</para>
                <example>
                    <title>Incomming Call CM event</title>
                    <programlisting><![CDATA[ CM_CALL_EVENT_INCOM(5) (Got from network)
 ---------------->     
     CM_CALL_EVENT_CALLER_ID (10) (Tell the caller info(CLI))
                ---------->   CM_CALL_EVENT_END (3) (user reject the call)]]></programlisting>
                </example>
                
                <para>QualComm defines a <userinput>cm_num_s_type</userinput> as the phone number structure.</para>
                
                <para>If a phone(13022593515) calling another mobile phone, the MO phone number would store as:</para>
                <informalexample>
                    <programlisting>struct {
  uint8 buf[CM_MAX_NUMBER_CHARS]; <userinput>13022593515</userinput>
  uint8 len;  <userinput>11</userinput>
  ...   ...
}cm_num_s_type;</programlisting>
                </informalexample>
            </sect3>
            
            <!-- Call End / Failed -->
            <sect3>
                <title>Call End/Failed</title>
                
                <para><userinput>cmxcall_end()</userinput> in <filename>cmxcall.c</filename> would take care of the end call
                action.</para>
                
                <para>This function contains useful log for <emphasis>Call Status</emphasis>, <emphasis>Call Type</emphasis>, etc.
                We usually need check these value in QXDM log:</para>
                <example>
                    <title>cmxcall_end() for ending call</title>
                    <programlisting>void cmxcall_end()
{
  LOG(<userinput>"CallEnd state=%d status=%d"</userinput>, call_ptr->call_state, call_ptr->end_status);
  LOG(<userinput>"CallType=%d SrvType=%d"</userinput>, call_ptr->call_type, call_ptr->srv_type);
  ...
  ...
}</programlisting>
                </example>
                
                <para>The <emphasis>Call State</emphasis> indicate current Call's state(such as MO/MT/etc). QualComm
                defined it as an enum(<userinput>cm_call_state_e</userinput>).</para>
                <table frame="topbot">
                <title>Call State in BP</title>
                <tgroup cols="2">
                
                <thead>
                    <row><entry>Value</entry><entry>Notes</entry></row>
                </thead>
                <tbody>
                    <row><entry>CM_CALL_STATE_IDLE(0)</entry><entry>Call is in idle state, i.e. no call </entry></row>
                    <row><entry>CM_CALL_STATE_ORIG(1)</entry><entry>Call is in origination state</entry></row>
                    <row><entry>CM_CALL_STATE_INCOM(2)</entry><entry>Call is in alerting state</entry></row>
                    <row><entry>CM_CALL_STATE_CONV(3)</entry><entry>Call is in conversation state</entry></row>
                </tbody>
                </tgroup>
                </table>
            
                <table frame="topbot">
                <title>Call End Status in BP</title>
                <tgroup cols="2">
                
                <thead>
                    <row><entry>Value</entry><entry>Notes</entry></row>
                </thead>
                <tbody>
                    <row><entry>CM_CALL_END_OFFLINE(0)</entry><entry>The phone is offline</entry></row>
                    <row><entry>CM_CALL_END_NO_SRV(21)</entry><entry>No Service, This is for backward compatibility,NO_CDMA_SRV and NO_GW_SRV are mapped to this.</entry></row>
                    <row><entry>CM_CALL_END_INTERCEPT(23)</entry><entry>Received an intercept from the BS -- originating only. CDMA only.</entry></row>
                    <row><entry>CM_CALL_END_CLIENT_END(29)</entry><entry>The client ended the call.</entry></row>
                </tbody>
                </tgroup>
                </table>
            </sect3>
        
            <sect3>
                <title>FDN</title>
                <para>The <emphasis>FDN</emphasis> will restrict your calling.</para>
                <para>It usually needs input your SIM card PIN2 code, before enable FDN.</para>
                    <indexterm>
                        <primary>FDN</primary>
                    </indexterm>
                <para>QualComm code has a <userinput>FEATURE_PACKET_CALL_FDN_CHECK</userinput> flag for support FDN, from
                modem layer.</para>
                <para>So, for <emphasis>MSM8960</emphasis> product, Moto didn't enable it at earlier stage. Later,
                it can add into <filename>build/ms/custaaaaakazq.h</filename> file, to let FDN work.</para>
            </sect3>
        </sect2>

        <sect2>
            <title>Call Forward</title>
            <para>Call Forward topic here</para>
        </sect2>
        
        <!-- NV Items -->
        <sect2>
            <title>NV Items</title>
            
            <para>The <emphasis>NV Items</emphasis> stored most of the BP-related config on the phone. They are specified
            by numerical number(NV ID), and QualComm uses <userinput>nv_items_enum_type</userinput> enum to represent it.</para>
            
            <para>Usually, Motorola extended the nv item, adding own items as well. To avoid conflict, these
            moto-specific items are began from offset <userinput>8000</userinput>:</para>
            
                <indexterm><primary>nv_items_enum_type</primary></indexterm>
            <informalexample>
                <programlisting> 1023 typedef enum {
 1024 
 1025   NV_ESN_I                     = 0,
 1026   NV_ESN_CHKSUM_I              = 1,
 8205   NV_MAX_I                     = 7225
 8207 #ifdef MOT_FEATURE_MOT_NV
 8208   ,
 8209   MOT_NV_FIRST_I             = 8000,
 8210   MOT_NV_FIELD_TEST_ENABLE_I = MOT_NV_FIRST_I,
 8211   MOT_NV_IN_FACTORY_I        = MOT_NV_FIRST_I+1,
 ...    ...
 } nv_items_enum_type;</programlisting>
            </informalexample>
            
            <para><filename>core/api/services/nv_items.h</filename> is the header defined all the NV items IDs, and their inner
            data structure.</para>
            <para>As so many IDs, and so many different structure for each ID, QualComm combines all these stuff into an union
            data type, <userinput>nv_item_type</userinput>.</para>
            
            <table frame="topbot">
                <title>QCOM NV Items Info</title>
            <tgroup cols="2">
                <colspec colwidth="1*" />
                <colspec colwidth="2*" />
                <thead>
                    <row><entry>Field</entry><entry>Notes</entry></row>
                </thead>
                <tbody>
                    <row><entry>Definition Header</entry><entry>core/api/services/nv_items.h</entry></row>
                    <row><entry>Source Code</entry><entry>core/services/nv/</entry></row>
                    <row><entry>ID</entry><entry>nv_items_enum_type, enum number</entry></row>
                    <row><entry>Data Structure</entry><entry>nv_item_type, union.</entry></row>
                    <row><entry>Moto Extend</entry><entry>start from offset 8000.</entry></row>
                </tbody>
            </tgroup>
            </table>
            <!-- Read/Write NV Items -->
            <sect3>
                <title>Read/Write NV Items</title>
                
                <para>QualComm allows read/write NV items through diag packet, and it defines a read/write protocol in diag specification.</para>
                
                <para>The read/write action would finally be dispatched to R/W the EFS <filename>/nvm/ID</filename> data.</para>
                
                <para>The draft logic flow is like this:</para>
                <informalexample>
                    <programlisting><![CDATA[
                 +----------+                      +----------+
 R/W diag req -> | nvdiag.c | --> nvio.c --------> | /nvm/xx/ |
                 +----------+            (EFS API) +----------+]]></programlisting>
                </informalexample>
                <para>Sometimes, we met the <emphasis>Inactive Items</emphasis> error when read a item, this is usually caused because there's
                no the NV ID file there, below is a sample code for this case:</para>
                <example>
                    <title>Inactive Item Cases</title>
                    <programlisting>nvio_read_item(nv_items_enum_type item, void *data_ptr,){
  snprintf(f_name,sizeof(f_name),"/nvm/num/%d",item);
  <userinput>if(efs_stat(f_name,&amp;temp_buf) == -1)
    return NV_NOTACTIVE_S;</userinput>
    
  status = efs_get(f_name, data_ptr, item_size);
  return status;
}</programlisting>
                </example>
                
                <para>As QualComm's implementation, there's protection when R/W the nv items. This can be found
                in below code:</para>
                <example>
                    <title>Protection of R/W</title>
                    <programlisting>void *nvdiag_read()
{
  //First check to see if this item is not allowed to be read.
  //NOTE:  These items are unreadable, even if security is unlocked!
  <userinput>if (unreadable_nv_item(eItem))</userinput> {
    return( diagpkt_err_rsp( DIAG_BAD_PARM_F, req_pkt, pkt_len ));
  }
}
boolean unreadable_nv_item(nv_items_enum_type item)
{
  switch(item){
    /* Keys, secrets, and passwords are unreadable */
    case NV_A_KEY_I:
     ...   ....
    case NV_SEC_DEVICE_KEY_I :
      return true;
      
    default: return false;
  }
}</programlisting>
                </example>
                
                <para>And furthermore, some NV items' write would require Service Programming Code(SPC) unlock. These
                protection can be found in <userinput>nvdiag_write()</userinput> implementation.</para>
                
                <para>The <emphasis>Service Programming Code Lock</emphasis>(SPC Lock) here, is a protection when accessing NV items.
                QualComm defined it as a DIAG msg(DIAG_SPC_F, 0x41).</para>
                
                <para>The code is value in <command>NV_SEC_CODE_I</command>(ID-85), which is a 6-digit number, the NV
                inner structure is:</para>
                <example>
                    <title>NV_SEC_CODE_I SPC data</title>
                    <programlisting>typedef PACKED struct PACKED_POST{
    /* The security code is fixed length(6),
       and is stored as ASCII string.*/
    byte  digits[NV_SEC_CODE_SIZE]; // NV_SEC_CODE_SIZE 6
}</programlisting>
                </example>
            </sect3>
            
            <sect3>
                <title>Some Comm NV Items Info</title>
                <para>The NV Items value can be a <emphasis>flex</emphasis> config file.</para>
                <para>For MSM8960(such as <emphasis>Vanquish</emphasis>), there's a <userinput>fsg</userinput>
                partition, and a <filename>fsg.mbn</filename> image file, which contain the EFS data. Thus loading a new NV data
                setting would be simple:</para>
                
                <informalexample>
                    <programlisting>$ <userinput>fastboot flash fsg fsg.mbn</userinput></programlisting>
                </informalexample>
                
                <para>The <filename>fsg.mbn</filename> file can be extracted by below commands:</para>
                <example>
                    <title>Dump the fsg.mbn</title>
                    <programlisting>mkdir temp
xxd -s 40 -p fsg.mbn | xxd -r -p - | tar xvf - -C temp
xxd temp/nvm/num/8034</programlisting>
                </example>
                
                <para>All <userinput>ID-XXX</userinput> item values are the <filename>/nvm/num/ID-XXX</filename> files,
                in binary format.</para>

                <para>There're some commonly-used NV items, that MUST be very familiar with them.</para>
                <table frame="topbot">
                <title>Some Commonly-used NV Items Info</title>
                <tgroup cols="2">
                <colspec colwidth="1*" />
                <colspec colwidth="2*" />
                <thead>
                    <row><entry>NV Item</entry><entry>Notes</entry></row>
                </thead>
                <tbody>
                    <row><entry>NV_HDR_AN_AUTH_NAI_I(579)</entry><entry></entry></row>
                    <row><entry>NV_HDR_AN_AUTH_PASSWORD_I(580)</entry><entry></entry></row>
                </tbody>
                </tgroup>
                </table>
                
            </sect3>
        </sect2>
        <!-- BP Panic -->
        <sect2>
            <title>BP Panic</title>
            
            <para>The <emphasis>BP Panic</emphasis> is a very huge topic, and always met in product development,
            especially in bring-up stage.</para>
            
            <sect3 id="qbp.bppanic.diagdumpcmd">
                <title>Common DIAG Coredump Command</title>
                
                <para>First, BP needs support QualComm's QXDM force panice, which is core dump action of diag extended
                msg.</para>
                
                <para>Type below commands in QXDM <guimenu>command</guimenu> window:</para>
                <informalexample>
                    <programlisting>send_data 75 37 03 00</programlisting>
                </informalexample>
                
                <para>The <userinput>75 37 03 00</userinput> is a DIAG payload which indicates:</para>
                
                <informalexample>
                    <programlisting>typedef struct{
  uint8 command_code; <userinput>DIAG_SUBSYS_CMD_F(75)</userinput>
  uint8 subsys_id;  <userinput>DIAG_SUBSYS_DEBUG(37)</userinput>
  uint16 subsys_cmd_code; <userinput>ERR_F3_TRACE_CORE_DUMP(0x0003)</userinput>
};</programlisting>
                </informalexample>
                
                <para>The corresponding handler is in <filename>core/debugtools/err/</filename>:</para>
                
                <example>
                    <title>Sample of handling the Panic Diag CMD</title>
                    <programlisting>/* core/debugtools/err/src/err_f3_trace.c */
static const diagpkt_user_table_entry_type err_f3_trace_tbl[] = {
<userinput>{ERR_F3_TRACE_CORE_DUMP,ERR_F3_TRACE_CORE_DUMP,err_f3_trace_core_dump_handler},</userinput>
{ERR_TEST_INVOKE_CRASH,ERR_TEST_INVOKE_CRASH,err_invoke_crash_handler},
...    ...
}</programlisting>
                </example>
            </sect3>
            <!-- Panic on MSM8960 -->
            <sect3>
                <title>Panic on MSM8960</title>
                
                <para>MSM8960 is one-single chip, BP is a <emphasis>subsystem</emphasis>, so there would 2 different
                result for a BP panic:</para>
                
                <itemizedlist>
                    <listitem>
                        <para><emphasis>Silent Reset</emphasis>, AP would try recovery the BP, the coredump file
                        would store somewhere. This won't cause AP restart.</para>
                    </listitem>
                    <listitem>
                        <para><emphasis>Download Dump Mode</emphasis>, whole chip goes into Download mode, using QualComm's
                        <emphasis>QPST</emphasis> to get the coredump. This would cause AP/BP down.</para>
                    </listitem>
                </itemizedlist>
                
                <para>Silent reset is prefered as it not required the whole system restart. It can be configured runtime to 
                decide to dump the panic file or not.</para>
                
                <para>This dump configured option can be either a property or a sysfs flag.</para>
                
                <para><userinput>setprop persist.radio.qc.ramdump.enable 1</userinput> will enable the ramdump, it would always
                enabled after system restart.</para>
                
                <para><userinput>echo "1">/sys/module/subsystem_restart/parameters/enable_ramdumps</userinput> is a one-shot
                enable, after system restart, it would be the default value set in kernel code(which is 0).</para>
                
                <para>In order to let MSM8960 system go into Download mode, it needs:</para>
                <itemizedlist spacing="compact">
                    <listitem>
                        <para>Set 2 NV items value to enable dump(see <xref linkend="tbl.qcom.msm8960.dumpnv" />)</para>
                    </listitem>
                    <listitem>
                        <para>Set <filename>/sys/module/restart/parameters/download_mode</filename> value to 1.</para>
                    </listitem>
                    <listitem>
                        <para>Set <filename>/sys/module/subsystem_restart/parameters/restart_level</filename> value to 1.</para>
                    </listitem>
                </itemizedlist>
                
                <table frame="topbot" id="tbl.qcom.msm8960.dumpnv">
                <title>NV Items of Donwload Dump Mode</title>
                    <tgroup cols="2">
                    <thead>
                    <row><entry>NV Item</entry><entry>Value</entry></row>
                    </thead>
                <tbody>
                    <row><entry>NV_ERR_FATAL_OPTIONS_I(ID-905)</entry><entry>0</entry></row>
                    <row><entry>NV_DETECT_HW_RESET_I(ID-4399)</entry><entry>1</entry></row>
                </tbody>
                    </tgroup>
                </table>
                
                <para>After system go into Download mode, using QPST to fetch the memory dump, the most important dump
                file is <filename>EBICS0.BIN</filename>. Use the wrapper script to figure out which line cause the crash:</para>
                
                <example>
                    <title></title>
                    <programlisting>$ <userinput>./bp-ramdump-parse.py -e AAAAANAZQ.elf -c EBICS0.BIN</userinput>
Error Message:Forced core dump %d, %d, %d
Error in file err_f3_trace.c, line 2090</programlisting>
                </example>
                
                <para>The <filename>AAAAANAZQ.elf</filename> is BP build symbol file, usually in <filename>build/AAAAANAZ/</filename> dir.</para>
            </sect3>
        </sect2>
    
        <sect2 id="qcom.msm8960.sn">
            <title>MSM8960 for ESN/MEID/IMEI</title>
            
            <para><filename>modem/datamodem/interface/qmidata/src/ds_qmi_dms.c</filename> handle device's serial number. </para>
            <para>The function usually be <userinput>qmi_dmsi_get_device_serial_numbers()</userinput>, it touched all these 3
            NV items, and it handle a <userinput>NV_UE_IMEISV_SVN_I</userinput> as well.</para>
            
            <para>After get all above data, the <userinput>qmi_dmsi_get_device_serial_numbers()</userinput> return the combined
            response to caller. Below is it's logic flow:</para>
            
            <example>
                <title>Device's ESN/MEID/IMEI handle logic</title>
                <programlisting>static dsm_item_type * qmi_dmsi_get_device_serial_numbers()
{
  dcc_get_nv_item( NV_UE_IMEI_I, dcc_nv_item_ptr ); <lineannotation>get IMEI NV</lineannotation>
  for(i = 1; i &lt;= dcc_nv_item_ptr->ue_imei[0]; i++){
    1. code decode to 14-digit IMEI.
    2. check sum a digit, as the 15-th digit
    3. copy the 15-digit to a value. <lineannotation>RIL use GET_IMEI to get this value.</lineannotation>
  }
  dcc_get_nv_item (NV_ESN_I, dcc_nv_item_ptr); <lineannotation>get ESN NV</lineannotation>
  dcc_get_nv_item (NV_MEID_I, dcc_nv_item_ptr); <lineannotation>get MEID NV</lineannotation>
  dcc_get_nv_item ( NV_UE_IMEISV_SVN_I , dcc_nv_item_ptr); 
  
  return response; <lineannotation>data contain all above data.</lineannotation>
}</programlisting>
            </example>
            
            <para><emphasis>Vanquish</emphasis> handles the MEID/IMEI specially, as required by VZW, it directly
            take 7-byte MEID + 1-digit CHKSM as IMEI, which also be 15-digit. But this required the MEID should not
            have hex nibble!</para>
        </sect2>
    </sect1>
    <!-- ============= Glossary =================  -->
    &section_glossary;

    <!-- index -->
    &section_index;
    
</article>
